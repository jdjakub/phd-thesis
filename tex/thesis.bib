@online{Prog21-dyn,
  title = "Dynamic Everything Else",
  url = "https://prog21.dadgum.com/182.html",
  author = "James Hague",
  year = "2013",
}
@book{SICM,
author = {Sussman, Gerald Jay and Wisdom, Jack},
title = {Structure and Interpretation of Classical Mechanics},
year = {2001},
isbn = {0262194554},
publisher = {MIT Press},
address = {Cambridge, MA, USA}
}
@online{SVG-rect,
  title = "SVG 1.1 Specification: 9.2 The ``rect'' Element",
  url = "https://www.w3.org/TR/SVG11/shapes.html#RectElement",
  author = {SVG, Working Group},
  year = "2011",
}
@online{Kell-vid,
  title = "Liberating the Smalltalk lurking in C and Unix",
  url = "https://youtu.be/LwicN2u6Dro?t=1353",
  year = "2014",
  author = "Stephen Kell",
}
@inproceedings{Externalize,
  title={Software and How it Lives On: Embedding Live Programs in the World Around Them},
  author={Antranig Basman and L. Church and C. Klokmose and Colin B. D. Clark},
  booktitle={PPIG},
  year={2016},
  url = {http://www.klokmose.net/clemens/wp-content/uploads/2016/10/ppig-2016.pdf},
}
@inproceedings{Kell-C,
author = {Kell, Stephen},
title = {Some Were Meant for {C}: The Endurance of an Unmanageable Language},
year = {2017},
isbn = {9781450355308},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3133850.3133867},
doi = {10.1145/3133850.3133867},
abstract = { The C language leads a double life: as an application programming language of yesteryear, perpetuated by circumstance; and as a systems programming language which remains a weapon of choice decades after its creation. This essay is a C programmer's reaction to the call to abandon ship. It questions several aspects commonly held to define the experience of using C; these include unsafety, undefined behaviour, and the motivation of performance. It argues all these are in fact inessential; rather, it traces C's ultimate strength to a communicative design which cannot be understood within the usual conception of "a programming language", but can be seen as the antithesis of so-called "managed" languages. This communicativity is understood as facilitating the essential aspect of system-building: creating parts which interact with other remote parts---being "alongside" not "within", and of "alien" origin. },
booktitle = {Proceedings of the 2017 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {229–245},
numpages = {17},
keywords = {undefined behavior, virtual machine, managed languages, safety, systems programming},
location = {Vancouver, BC, Canada},
series = {Onward! 2017}
}
@online{Semprola,
  title = "Semprola: a semiotic programming language",
  url = "https://www.shift-society.org/salon/papers/2018/revised/semprola.pdf",
  year = "2018",
  author = "Oli Sharpe",
}
@inproceedings{Crit-semprola,
  author = {Basman, Antranig},
  title = {Critique of ‘Semprola: A Semiotic Programming Language’},
  year = {2018},
  isbn = {9781450355131},
  url = {https://doi.org/10.1145/3191697.3214331},
  doi = {10.1145/3191697.3214331},
  booktitle = {Conference Companion of the 2nd International Conference on Art, Science, and Engineering of Programming},
  pages = {214–217},
  location = {Nice, France},
  series = {Programming’18 Companion}
}
@online{COLAs,
  title = "Accessible Language-Based Environments of Recursive Theories",
  url = "http://www.vpri.org/pdf/rn2006001a_colaswp.pdf",
  author = {Ian Piumarta},
  year = "2006",
}
@inbook{OROM,
author = {Piumarta, Ian and Warth, Alessandro},
title = {Open, Extensible Object Models},
year = {2008},
isbn = {9783540892748},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {http://www.vpri.org/pdf/tr2006003a_objmod.pdf},
doi = {10.1007/978-3-540-89275-5_1},
abstract = {Programming languages often hide their implementation at a level of abstraction that is inaccessible to programmers. Decisions and tradeoffs made by the language designer at this level (single vs. multiple inheritance, mixins vs. Traits, dynamic dispatch vs. static case analysis, etc.) cannot be repaired easily by the programmer when they prove inconvenient or inadequate. The artificial distinction between implementation language and end-user language can be eliminated by implementing the language using only end-user objects and messages, making the implementation accessible for arbitrary modification by programmers. We show that three object types and five methods are sufficient to bootstrap an extensible object model and messaging semantics that are described entirely in terms of those same objects and messages. Raising the implementation to the programmers' level lets them design and control their own implementation mechanisms in which to express concise solutions and frees the original language designer from ever having to say "I'm sorry".},
booktitle = {Self-Sustaining Systems: First Workshop, S3 2008 Potsdam, Germany, May 15-16, 2008 Revised Selected Papers},
pages = {1–30},
numpages = {30}
}
@inproceedings{OECM,
author = {Piumarta, Ian},
title = {Open, Extensible Composition Models},
year = {2011},
isbn = {9781450308922},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {http://www.vpri.org/pdf/tr2011002_oecm.pdf},
doi = {10.1145/2068776.2068778},
abstract = {Simple functional languages like LISP are useful for exploring novel semantics and composition mechanisms. That usefulness can be limited by the assumptions built into the evaluator about the structure of data and the meaning of expressions. These assumptions create difficulties when a program introduces a composition mechanism that differs substantially from the built-in mechanism of function application. We explore how an evaluator can be constructed to eliminate most built-in assumptions about meaning, and show how new composition mechanisms can be introduced easily and seamlessly into the language it evaluates.},
booktitle = {Proceedings of the 1st International Workshop on Free Composition},
articleno = {2},
numpages = {5},
location = {Lancaster, United Kingdom},
series = {FREECO '11}
}
@phdthesis{OMeta,
  title = "Experimenting with Programming Languages",
  url = "http://www.vpri.org/pdf/tr2008003_experimenting.pdf",
  author = {Alessandro Warth},
  school  = "University of California",
  address = "Los Angeles, CA",
  year = "2009",
}
@article{Cassowary,
  title = "Solving Linear Arithmetic Constraints for User Interface Applications",
  url = "https://constraints.cs.washington.edu/solvers/uist97.html",
  author = "Alan Borning and Kim Marriott and Peter Stuckey and Yi Xiao",
  year = "1997",
  journaltitle = "Proceedings of the 1997 ACM Symposium on User Interface Software and Technology",
  pages = "87--96",
}
@article{Boxer,
author = {Andrea A. diSessa and Abelson, H.},
title = {Boxer: A Reconstructible Computational Medium},
year = {1986},
issue_date = {Sept. 1986},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {29},
number = {9},
issn = {0001-0782},
url = {https://doi.org/10.1145/6592.6595},
doi = {10.1145/6592.6595},
abstract = {Programming is most often viewed as a way for experts to get computers to perform complex tasks efficiently and reliably. Boxer presents an alternative image—programming as a way for nonexperts to control a reconstructible medium, much like written language, but with dramatically extended interactive capabilities.},
journal = {Commun. ACM},
month = {09},
pages = {859–868},
numpages = {10}
}
@article{Boxer-design,
author = {Andrea A. diSessa},
title = {A Principled Design for an Integrated Computational Environment},
journal = {Human–Computer Interaction},
volume = {1},
number = {1},
pages = {1-47},
year  = {1985},
publisher = {Taylor \& Francis},
doi = {10.1207/s15327051hci0101\_1},
URL = { https://doi.org/10.1207/s15327051hci0101_1 },
}
@online{Orom-html,
  title = "Hacking together OROM/DOM+Ctrl+Shift+J",
  url = "https://programmingmadecomplicated.wordpress.com/2018/01/18/3-hacking-together-orom-domctrlshiftj/",
  year = "2018",
  author = "Joel Jakubovic",
}
@online{Steps06,
  title = "Proposal to NSF",
  url = "http://www.vpri.org/pdf/rn2006002_nsfprop.pdf",
  year = "2006",
  author = {Alan Kay and Dan Ingalls and Yoshiki Oshima and Ian Piumarta and Andreas Raab},
}
@online{Steps07,
  title = "STEPS Toward The Reinvention of Programming, First Year Progress Report",
  url = "ttp://www.vpri.org/pdf/tr2007008_steps.pdf",
  year = "2007",
  author = {Alan Kay and Ian Piumarta and Kim Rose and Dan Ingalls and Dan Amelang and
            Ted Kaehler and Yoshiki Ohshima and Scott Wallace and Alessandro Warth and Takashi Yamamiya},
}
@online{Steps08,
  title = "STEPS Toward The Reinvention of Programming, 2008 Progress Report",
  url = "http://www.vpri.org/pdf/tr2008004_steps08.pdf",
  year = "2008",
  author = {Alan Kay and Ian Piumarta and Kim Rose and Dan Ingalls and Dan Amelang and
            Ted Kaehler and Yoshiki Ohshima and H. Samimi and Chuck Thacker and
            S. Wallace and Alessandro Warth and Takashi Yamamiya},
}
@online{Steps09,
  title = "STEPS Toward The Reinvention of Programming, 2009 Progress Report",
  url = "http://www.vpri.org/pdf/tr2009016_steps09.pdf",
  year = "2009",
  author = {Alan Kay and Ian Piumarta and Kim Rose and D. Ingalls and Dan Amelang and
            Ted Kaehler and Yoshiki Ohshima and H. Samimi and Chuck Thacker and
            S. Wallace and Alessandro Warth and Takashi Yamamiya},
}
@online{Steps10,
  title = "STEPS Toward Expressive Programming Systems, 2010 Progress Report",
  url = "http://www.vpri.org/pdf/tr2010004_steps10.pdf",
  year = "2010",
  author = {{ViewPoints Research Institute}},
  shortauthor = {{VPRI}},
}
@online{Steps11,
  title = "STEPS Toward Expressive Programming Systems, 2011 Progress Report",
  url = "http://www.vpri.org/pdf/tr2011004_steps11.pdf",
  year = "2011",
  author = {Dan Amelang and Bert Freudenberg and Ted Kaehler and Alan Kay and Stephen Murrell and
            Yoshiki Ohshima and Ian Piumarta and Kim Rose and Scott Wallace and
            Alessandro Warth and Takashi Yamamiya},
}
@online{Steps12,
  title = "STEPS Toward the Reinvention of Programming, 2012 Final Report",
  url = "http://www.vpri.org/pdf/tr2012001_steps.pdf",
  year = "2012",
  author = {Dan Amelang and Bert Freudenberg and Ted Kaehler and Alan Kay and Stephen Murrell and
            Yoshiki Ohshima and Ian Piumarta and Kim Rose and Scott Wallace and
            Alessandro Warth and Takashi Yamamiya},
}
@online{DDV,
  title = "Drawing Dynamic Visualisations",
  url = "http://worrydream.com/#!/DrawingDynamicVisualizationsTalk",
  year = "2013",
  author = "Bret Victor",
}
@inproceedings{Meta-helix,
author = {Polito, Guillermo and Ducasse, St\'{e}phane and Bouraqadi, Noury and Fabresse, Luc},
title = {A Bootstrapping Infrastructure to Build and Extend Pharo-like Languages},
year = {2015},
isbn = {9781450336888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2814228.2814236},
doi = {10.1145/2814228.2814236},
booktitle = {2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward!)},
pages = {183–196},
numpages = {14},
keywords = {Pharo, Bootstrapping, Metaprogramming, Traits, OOP},
location = {Pittsburgh, PA, USA},
series = {Onward! 2015}
}
@online{Bootfrom0,
  title = "Bootstrapping A Simple Compiler From Nothing",
  author = "Edmund Grimley Evans",
  year = "2001",
  url = "https://web.archive.org/web/20061108010907/http://www.rano.org/bcompiler.html"
}
@phdthesis{ProcRefl,
  title = "Procedural Reflection in Programming Languages",
  url = "https://dspace.mit.edu/handle/1721.1/15961",
  author = "Brian Cantwell Smith",
  school = "Massachusetts Institute of Technology",
  year = "1982",
}
@phdthesis{Sketchpad,
  title = "Sketchpad: A man-machine graphical communication system",
  url = "https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-574.pdf",
  author = "Ivan Edward Sutherland",
  school = "Massachusetts Institute of Technology",
  year = "1963",
  doi = {https://doi.org/10.1145/1461551.1461591},
}
@book{WWID,
  url = "http://acypher.com/wwid/",
  title = "Watch What I Do",
  subtitle = "Programming by Demonstration",
  editor = "Allen Cypher",
  year = "1993",
  publisher = "The MIT Press",
}
@book{YWIMC,
  url = "https://www.sciencedirect.com/book/9781558606883/your-wish-is-my-command",
  title = "Your Wish Is My Command",
  subtitle = "Programming By Example",
  publisher = {Morgan Kaufmann},
  editor = "Henry Lieberman",
  year = "2001",
}
@online{VPcodex,
  title = "Visual Programming Codex",
  url = "https://github.com/ivanreese/visual-programming-codex",
  author = "Ivan Reese",
  year = {2022},
}
@book{VPsurvey,
  title={Visual programming},
  author={Nickerson, Jeffrey Vernon},
  year={1994},
  publisher={New York University},
  url={https://web.stevens.edu/jnickerson/ch2.pdf},
}
@online{GalleryUIs,
  url = "https://alarmingdevelopment.org/?p=1068",
  author = "Jonathan Edwards",
  year = "2017",
  title = "Gallery of Programming UIs",
}
@online{Forms3,
  url = "http://web.engr.oregonstate.edu/~burnett/Forms3/Tour/tour.html",
  title = "A Guided Tour of Forms/3",
  author = "Judith Hays, Margaret Burnett",
  year = "1995",
}
@article{Palimpsest,
title = "Palimpsest: A layered language for exploratory image processing",
journal = "Journal of Visual Languages \& Computing",
volume = "25",
number = "5",
pages = "545 - 571",
year = "2014",
issn = "1045-926X",
doi = "https://doi.org/10.1016/j.jvlc.2014.07.001",
url = "http://www.sciencedirect.com/science/article/pii/S1045926X14000627",
author = "Alan F. Blackwell",
}
@INPROCEEDINGS{Hopscotch,
    url = "http://bracha.org/hopscotch-wasdett.pdf",
    author = {Vassili Bykov},
    title = {Hopscotch: Towards user interface composition},
    booktitle = {ECOOP 2008 International Workshop on Advanced Software Development Tools and Techniques (WASDeTT},
    year = {2008}
}
@online{Nile,
  url = "https://github.com/damelang/nile",
  title = "The Nile Programming Language",
  author = "Dan Amelang",
  subtitle = "Declarative Stream Processing for Media Applications",
  year = "2012",
}
@phdthesis{Infra,
  title = "A New Human-Readability Infrastructure for Computing",
  url = "http://www.christopherkhall.com/Dissertation.pdf",
  author = "Christopher K. Hall",
  school = "University of California",
  address = "Santa Barbara, CA",
  year = "2017",
}
@inproceedings{Infra-paper,
author = {Hall, Christopher and Standley, Trevor and Hollerer, Tobias},
title = {Infra: Structure All the Way down: Structured Data as a Visual Programming Language},
year = {2017},
isbn = {9781450355308},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3133850.3133852},
doi = {10.1145/3133850.3133852},
abstract = {We present Infra, a new baseline medium for representing data. With Infra, arbitrarily-complex structured data can be encoded, viewed, edited, and processed, all while remaining in an efficient non-textual form. It is suitable for the full range of information modalities, from free-form input, to compact schema-conforming structures. With its own equivalent of a text editor and text-field widget, Infra is designed to target the domain currently dominated by flat character strings while simultaneously enabling the expression of sub-structure, inter-reference, dynamic dependencies, abstraction, computation, and context (metadata). Existing metaformats fit neatly into two categories. They are either textual for human readability (such as XML and JSON) or binary for compact serialization (such as Thrift and Protocol Buffers). In contrast, Infra unifies those two paradigms. In order to have the desirable properties of binary formats, Infra has no textual representation. And yet, it is designed to be easily read and authored by end-users. We show how the organization Infra brings to data makes a new non-textual programming paradigm viable. Programs that modify data can now be embedded into the data itself. Furthermore, these programs can often be authored by demonstration. We argue that Infra can be used to improve existing software projects and that bringing direct authoring and human readability to a binary data paradigm could have rippling ramifications on the computing landscape.},
booktitle = {Proceedings of the 2017 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {180–197},
numpages = {18},
keywords = {metaformat, human-readability, structure editing, end-user development},
location = {Vancouver, BC, Canada},
series = {Onward! 2017}
}
@inproceedings{Subtext,
author = {Edwards, Jonathan},
title = {Subtext: Uncovering the Simplicity of Programming},
year = {2005},
isbn = {1595930310},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1094811.1094851},
doi = {10.1145/1094811.1094851},
abstract = {Representing programs as text strings makes programming harder then it has to be. The source text of a program is far removed from its behavior. Bridging this conceptual gulf is what makes programming so inhumanly difficult -- we are not compilers. Subtext is a new medium in which the representation of a program is the same thing as its execution. Like a spreadsheet, a program is visible and alive, constantly executing even as it is edited. Program edits are coherent semantic transformations.The essence of this new medium is copying. Programs are constructed by copying and executed by copy flow: the projection of changes through copies. The simple idea of copying develops into a rich theory of higher-order continual copying of trees. Notably absent are symbolic names, the workhorse of textual notation, replaced by immediately-bound explicit relationships. Subtext unifies traditionally distinct programming tools and concepts, and enables some novel ones. Ancestral structures are a new primitive data type that combines the features of lists and records, along with unproblematic multiple inheritance. Adaptive conditionals use first-class program edits to dynamically adapt behavior.A prototype implementation shows promise, but calls for much further research. Subtext suggests that we can make programming radically easier, if we are willing to be radical.},
booktitle = {Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {505–518},
numpages = {14},
keywords = {copying, prototypes, non-textual programming, visual programming},
location = {San Diego, CA, USA},
series = {OOPSLA '05}
}
@misc{SchemTab,
title = {Schematic Tables},
url = {http://www.subtext-lang.org/OOPSLA07.pdf},
}
@article{FPexplain,
author = {Perera, Roly and Acar, Umut A. and Cheney, James and Levy, Paul Blain},
title = {Functional Programs That Explain Their Work},
year = {2012},
issue_date = {September 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2398856.2364579},
doi = {10.1145/2398856.2364579},
journal = {SIGPLAN Not.},
month = sep,
pages = {365–376},
numpages = {12},
keywords = {debugging, program slicing, provenance}
}
@TECHREPORT{Boomerang,
    url = "https://www.cis.upenn.edu/~bcpierce/papers/boomerang.pdf",
    author = {Aaron Bohannon and J. Nathan Foster and Benjamin C. Pierce and Alexandre Pilkiewicz and École Polytechnique and Alan Schmitt},
    title = {Boomerang: Resourceful lenses for string data},
    year = {2007}
}
@article{Sketchnsketch,
author = {Mayer, Mika\"{e}l and Kuncak, Viktor and Chugh, Ravi},
title = {Bidirectional Evaluation with Direct Manipulation},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276497},
doi = {10.1145/3276497},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {127},
numpages = {28},
keywords = {Direct Manipulation, Bidirectional Programming, Sketch-n-Sketch}
}
@inproceedings{Kell-OS,
author = {Kell, Stephen},
title = {The Operating System: Should There Be One?},
year = {2013},
isbn = {9781450324601},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2525528.2525534},
doi = {10.1145/2525528.2525534},
abstract = {Operating systems and programming languages are often informally evaluated on their conduciveness towards composition. We revisit Dan Ingalls' Smalltalk-inspired position that "an operating system is a collection of things that don't fit inside a language; there shouldn't be one", discussing what it means, why it appears not to have materialised, and how we might work towards the same effect in the postmodern reality of today's systems. We argue that the trajectory of the "file" abstraction through Unix and Plan 9 culminates in a Smalltalk-style object, with other filesystem calls as a primitive metasystem. Meanwhile, the key features of Smalltalk have many analogues in the fragmented world of Unix programming (including techniques at the library, file and socket level). Based on the themes of unifying OS- and language-level mechanisms, and increasing the expressiveness of the meta-system, we identify some evolutionary approaches to a postmodern realisation of Ingalls' vision, arguing that an operating system is still necessary after all.},
booktitle = {Proceedings of the Seventh Workshop on Programming Languages and Operating Systems},
articleno = {8},
numpages = {7},
keywords = {Unix, plan 9, metasystem, integration, composition, binding, smalltalk},
location = {Farmington, Pennsylvania},
series = {PLOS '13}
}
@inproceedings{KellMMM,
  title={The mythical matched modules: overcoming the tyranny of inflexible software construction},
  subtitle={Overcoming the tyranny of inflexible software construction},
  author={Stephen Kell},
  booktitle={OOPSLA Companion},
  year={2009}
}
@online{Wisdom,
  title = "Programming Wisdom Center",
  url = "https://www.geocitiesarchive.org/arclc/t/a/tablizer/index.html",
  year = "2005",
  author = "Findy Services and B. Jacobs",
}
@online{TOP,
  url = "http://wiki.c2.com/?TopMind",
  title = "TOP (Table Oriented Programming) Mind",
  author = "TopMind",
  year = {2014}
}
@online{RightTool,
  url = {https://wiki.c2.com/?PickTheRightToolForTheJob},
  title = {Pick The Right Tool For The Job},
  author = {{C2 Contributors}},
  year = {2014},
}
@online{Mem-mods,
url = {http://canonical.org/~kragen/memory-models/},
author = {Sitaker, Kragen Javier},
title = {The Memory Models That Underlie Programming Languages},
year = {2016},
}
@online{Entangle-critique,
  url = "https://www.shift-society.org/salon/papers/2018/critiques/critique-anatomy-of-interaction.pdf",
  title = "Critique of ``An Anatomy of Interaction: Co-occurrences and Entanglements''",
  year = "2018",
  author = "Tomas Petricek",
}
@inproceedings{Evaluating-systems,
  author    = {Jonathan Edwards and Stephen Kell and
               Tomas Petricek and Luke Church},
  title     = {Evaluating programming systems design},
  booktitle = {Proceedings of 30th Annual Workshop of
               Psychology of Programming Interest Group},
  series    = {PPIG 2019},
  location  = {Newcastle, UK},
  year      = {2019}
}
inproceedings{CCS20,
  title = "What it takes to create with domain-appropriate tools",
  subtitle = "Reflections on implementing the ``Id'' system",
  author = "Joel Jakubovic",
  year = "2020",
  series = "Convivial Computing Salon 2020",
  location = "Porto, Portugal",
}
@online{CCS20-talk,
  url = "https://www.youtube.com/watch?v=uXv_386TyqY",
  title = "What it takes to create with domain-appropriate tools",
  author = "Joel Jakubovic",
  year = "2020",
  series = "Convivial Computing Salon 2020",
  location = "Porto, Portugal",
}
@inproceedings{Webstrates,
author = {Klokmose, Clemens N. and Eagan, James R. and Baader, Siemen and Mackay, Wendy and Beaudouin-Lafon, Michel},
title = {Webstrates: Shareable Dynamic Media},
year = {2015},
isbn = {9781450337793},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2807442.2807446},
doi = {10.1145/2807442.2807446},
abstract = {We revisit Alan Kay's early vision of dynamic media that blurs the distinction between documents and applications. We introduce shareable dynamic media that are malleable by users, who may appropriate them in idiosyncratic ways; shareable among users, who collaborate on multiple aspects of the media; and distributable across diverse devices and platforms. We present Webstrates, an environment for exploring shareable dynamic media. Webstrates augment web technology with real-time sharing. They turn web pages into substrates, i.e. software entities that act as applications or documents depending upon use. We illustrate Webstrates with two implemented case studies: users collaboratively author an article with functionally and visually different editors that they can personalize and extend at run-time; and they orchestrate its presentation and audience participation with multiple devices. We demonstrate the simplicity and generative power of Webstrates with three additional prototypes and evaluate it from a systems perspective.},
booktitle = {Proceedings of the 28th Annual ACM Symposium on User Interface Software \& Technology},
pages = {280–290},
numpages = {11},
keywords = {web, real-time collaborative documents, dynamic media},
location = {Charlotte, NC, USA},
series = {UIST '15}
}
@online{Dadgum66,
  title = "Living Inside Your Own Black Box",
  url = "https://prog21.dadgum.com/66.html",
  author = "James Hague",
  year = "2010",
}
@proceedings{SSS-08,
  editor    = {Kim Rose and Robert Hirschfeld},
  title     = {Self-Sustaining Systems, First Workshop},
  location  = {Potsdam, Germany},
  abstract  = { S3 is a forum for discussion of topics relating to computer systems
                and languages that are able to bootstrap, implement, modify, and maintain
                themselves. One property of these systems is that their implementation is
                based on small but powerful abstractions; examples include (amongst others)
                Squeak/Smalltalk, COLA, Klein/Self, PyPy/Python, Rubinius/Ruby, and Lisp.
                Such systems are the engines of their own replacement, giving researchers
                and developers great power to experiment with, and explore future directions
                from within their own small language kernels.},
  series    = {Lecture Notes in Computer Science},
  volume    = {5146},
  publisher = {Springer},
  year      = {2008},
  url       = {https://doi.org/10.1007/978-3-540-89275-5},
  doi       = {10.1007/978-3-540-89275-5},
  isbn      = {978-3-540-89274-8},
  timestamp = {Tue, 14 May 2019 10:00:51 +0200},
  biburl    = {https://dblp.org/rec/conf/s3/2008.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@proceedings{SSS-10,
  editor    = {Kim Rose and Robert Hirschfeld and Hidehiko Masuhara},
  title     = {Workshop on Self-Sustaining Systems},
  location  = {Tokyo, Japan},
  abstract  = {The Workshop on Self-sustaining Systems (S3) is a forum for discussion
              of topics relating to computer systems and languages that are able to bootstrap,
              implement, modify, and maintain themselves. One property of these systems is that
              their implementation is based on small but powerful abstractions; examples include
              (amongst others) Squeak/Smalltalk, COLA, Klein/Self, PyPy/Python, Rubinius/ Ruby,
              and Lisp. Such systems are the engines of their own replacement, giving researchers
              and developers great power to experiment with, and explore future directions from
              within, their own small language kernels.},
  publisher = {{ACM}},
  year      = {2010},
  url       = {https://doi.org/10.1145/1942793},
  doi       = {10.1145/1942793},
  isbn      = {978-1-4503-0491-7},
  timestamp = {Tue, 06 Nov 2018 16:58:26 +0100},
  biburl    = {https://dblp.org/rec/conf/s3/2010.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{Varv,
author = {Borowski, Marcel and Murray, Luke and Bagge, Rolf and Kristensen, Janus Bager and Satyanarayan, Arvind and Klokmose, Clemens Nylandsted},
title = {Varv: Reprogrammable Interactive Software as a Declarative Data Structure},
year = {2022},
isbn = {9781450391573},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3491102.3502064},
doi = {10.1145/3491102.3502064},
abstract = {Most modern applications are immutable and turn-key despite the acknowledged benefits of empowering users to modify their software. Writing extensible software remains challenging, even for expert programmers. Reprogramming or extending existing software is often laborious or wholly blocked, requiring sophisticated knowledge of application architecture or setting up a development environment. We present Varv, a programming model representing reprogrammable interactive software as a declarative data structure. Varv defines interactive applications as a set of concepts that consist of a schema and actions. Applications in Varv support incremental modification, allowing users to reprogram through addition and selectively suppress, modify, or add behavior. Users can define high-level concepts, creating an abstraction layer and effectively a domain-specific language for their application domain, emphasizing reuse and modification. We demonstrate the reprogramming and collaboration capabilities of Varv in two case studies and illustrate how the event engine allows for extensive tooling support.},
booktitle = {Proceedings of the 2022 CHI Conference on Human Factors in Computing Systems},
articleno = {492},
numpages = {20},
keywords = {reprogramming, real-time collaboration, interactive software, liveness, declarative programming},
location = {New Orleans, LA, USA},
series = {CHI '22}
}
@inproceedings{PLrev,
author = {Gabriel, Richard P.},
title = {The Structure of a Programming Language Revolution},
year = {2012},
isbn = {9781450315623},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2384592.2384611},
doi = {10.1145/2384592.2384611},
abstract = {Engineering often precedes science. Incommensurability is real.},
booktitle = {Proceedings of the ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {195–214},
numpages = {20},
keywords = {science, incommensurability, engineering, paradigms},
location = {Tucson, Arizona, USA},
series = {Onward! 2012}
}
@inproceedings{Mu,
author = {Agaram, Kartik},
title = {Bicycles for the Mind Have to Be See-Through},
year = {2020},
isbn = {9781450375078},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3397537.3397547},
doi = {10.1145/3397537.3397547},
abstract = {This paper describes ongoing research on building software to be comprehensible to its users so that they can tailor it to their needs in the field. Our test-bed is a computing stack called Mu that deemphasizes a clean interface in favor of a few global implementation properties: small implementation size, few distinct notations, parsimonious dependencies, a simple dependency graph that avoids cycles, and early warning on breaking changes. Assuming a 32-bit x86 processor and (for now) a basic third-party Unix-like kernel, Mu builds up from raw machine code to a memory-safe but less expressive language than C. Our approach to keeping software comprehensible is to reduce information hiding and abstraction, and instead encourage curiosity about internals. Our hypothesis is that abstractions help insiders who understand a project but hinder newcomers who understand only that project's domain. Where recent efforts to create "bicycles for the mind" have tended to focus on reducing learning time and effort, we explore organizing the curriculum to be incrementally useful, providing an hour of actionable value for an hour (or three) of study. The hope is that rewarding curiosity will stimulate curiosity in a virtuous cycle, so that more people are motivated to study and reflect on the difference between good vs bad design and good vs bad architecture, even as the study takes place over a lifetime of specialization in other domains. Spreading expertise in design is essential to the creation of a better society of more empowered citizens. Software tools have a role to play in this process, both by exemplifying good design and by providing visceral illustrations of the consequences of design choices.},
booktitle = {Conference Companion of the 4th International Conference on Art, Science, and Engineering of Programming},
pages = {173–186},
numpages = {14},
keywords = {software literacy},
location = {Porto, Portugal},
series = {<Programming> '20}
}
@online{Masp,
  title = "Masp Brainstorming",
  url = {https://wiki.c2.com/?MaspBrainstorming},
  author = {{C2 Contributors}},
  year = "2014",
}
@online{Gezira,
  title = "Gezira",
  url = {https://github.com/damelang/gezira},
  author = "Dan Amelang",
  year = "2012",
}
@article{Hazel,
author = {Omar, Cyrus and Voysey, Ian and Chugh, Ravi and Hammer, Matthew A.},
title = {Live Functional Programming with Typed Holes},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290327},
doi = {10.1145/3290327},
abstract = {Live programming environments aim to provide programmers (and sometimes audiences) with continuous feedback about a program's dynamic behavior as it is being edited. The problem is that programming languages typically assign dynamic meaning only to programs that are complete, i.e. syntactically well-formed and free of type errors. Consequently, live feedback presented to the programmer exhibits temporal or perceptive gaps. This paper confronts this "gap problem" from type-theoretic first principles by developing a dynamic semantics for incomplete functional programs, starting from the static semantics for incomplete functional programs developed in recent work on Hazelnut. We model incomplete functional programs as expressions with holes, with empty holes standing for missing expressions or types, and non-empty holes operating as membranes around static and dynamic type inconsistencies. Rather than aborting when evaluation encounters any of these holes as in some existing systems, evaluation proceeds around holes, tracking the closure around each hole instance as it flows through the remainder of the program. Editor services can use the information in these hole closures to help the programmer develop and confirm their mental model of the behavior of the complete portions of the program as they decide how to fill the remaining holes. Hole closures also enable a fill-and-resume operation that avoids the need to restart evaluation after edits that amount to hole filling. Formally, the semantics borrows machinery from both gradual type theory (which supplies the basis for handling unfilled type holes) and contextual modal type theory (which supplies a logical basis for hole closures), combining these and developing additional machinery necessary to continue evaluation past holes while maintaining type safety. We have mechanized the metatheory of the core calculus, called Hazelnut Live, using the Agda proof assistant. We have also implemented these ideas into the Hazel programming environment. The implementation inserts holes automatically, following the Hazelnut edit action calculus, to guarantee that every editor state has some (possibly incomplete) type. Taken together with this paper's type safety property, the result is a proof-of-concept live programming environment where rich dynamic feedback is truly available without gaps, i.e. for every reachable editor state.},
journal = {Proc. ACM Program. Lang.},
month = {01},
articleno = {14},
numpages = {32},
keywords = {typed holes, live programming, contextual modal type theory, structured editing, gradual typing}
}
@inproceedings{CompRev,
author = {Alan Kay},
title = {The Computer Revolution Hasn't Happened yet (Keynote Session)},
year = {2000},
isbn = {1581131984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/354384.354390},
doi = {10.1145/354384.354390},
abstract = {The printing press was invented in the middle of the 15th century, yet it took 100 years before a book was considered dangerous enough to be banned. 150 years before science was invented, almost 200 years before a new kind of political essay was invented, and more than 300 hundred years before a country with an invented political system (the US) could be argued into existence via the press and a citizenry that could understand the arguments. Schooling and general literacy were also fruits of the press, and also took many centuries to become established. The commercial computer is now about 50 years old and is still imitating the paper culture that came before it, just as the printing press did with the manuscript culture it gradually replaced. No media revolution can be said to have happened without a general establishment of “literacy”: fluent “reading” and “writing” at the highest level of ideas that the medium can represent. With computers, we are so far from that fluent literacy — or even understanding what that literacy should resemble — that we could claim that the computer revolution hasn't even started. This talk will try to put a shape to the real computer revolution to come.},
booktitle = {Proceedings of the Eighth ACM International Conference on Multimedia},
pages = {1},
location = {Marina del Rey, California, USA},
series = {MULTIMEDIA '00}
}
@unpublished{DynPat,
title = {Design patterns in dynamic programming},
author = {Peter Norvig},
year = {1996},
note = {Object World, Boston, MA},
URL = {https://norvig.com/design-patterns/},
}
@misc{Altair,
  author = {Tim Colegrove},
  title = {Own work, {CC BY-SA} 4.0},
  url = {https://commons.wikimedia.org/w/index.php?curid=89430810},
  year = {2020}
}
@article{SWE-impact,
author = {Ryder, Barbara G. and Soffa, Mary Lou and Burnett, Margaret},
title = {The Impact of Software Engineering Research on Modern Programming Languages},
year = {2005},
issue_date = {October 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {4},
issn = {1049-331X},
url = {https://doi.org/10.1145/1101815.1101818},
doi = {10.1145/1101815.1101818},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {oct},
pages = {431–477},
numpages = {47},
keywords = {Software Engineering, Programming Languages}
}
@inproceedings{Antifragile,
author = {Monperrus, Martin},
title = {Principles of Antifragile Software},
year = {2017},
isbn = {9781450348362},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3079368.3079412},
doi = {10.1145/3079368.3079412},
abstract = {There are many software engineering concepts and techniques related to software errors. But is this enough? Have we already completely explored the software engineering noosphere with respect to errors and reliability? In this paper, I discuss an novel concept, called "software antifragility", that is unconventional and has the capacity to improve the way we engineer errors and dependability in a disruptive manner. This paper first discusses the foundations of software antifragilty, from classical fault tolerance to the most recent advances on automatic software repair and fault injection in production. This paper then explores the relation between the antifragility of the development process and the antifragility of the resulting software product.},
booktitle = {Companion to the First International Conference on the Art, Science and Engineering of Programming},
articleno = {32},
numpages = {4},
keywords = {automatic software repair, runtime repair, reliability, antifragility, failure injection in production, chaos engineering},
location = {Brussels, Belgium},
series = {Programming '17}
}
@article{LivingWithErrors,
  author    = {Tomas Petricek},
  title     = {Miscomputation in software: Learning to live with errors},
  journal   = {Art Sci. Eng. Program.},
  volume    = {1},
  number    = {2},
  pages     = {14},
  year      = {2017},
  url       = {https://doi.org/10.22152/programming-journal.org/2017/1/14},
  doi       = {10.22152/programming-journal.org/2017/1/14},
  timestamp = {Wed, 17 Feb 2021 08:59:22 +0100},
  biburl    = {https://dblp.org/rec/journals/programming/000117.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@article{Miscomputation,
  title={Miscomputation},
  author={Fresco, Nir and Primiero, Giuseppe},
  journal={Philosophy \& Technology},
  volume={26},
  number={3},
  pages={253--272},
  year={2013},
  publisher={Springer}
}

@article{MalfunctioningSW,
  title={On malfunctioning software},
  author={Floridi, Luciano and Fresco, Nir and Primiero, Giuseppe},
  journal={Synthese},
  volume={192},
  number={4},
  pages={1199--1220},
  year={2015},
  publisher={Springer}
}
@inproceedings{ChaosMonkey,
author = {Chang, Michael Alan and Tschaen, Bredan and Benson, Theophilus and Vanbever, Laurent},
title = {Chaos Monkey: Increasing {SDN} Reliability through Systematic Network Destruction},
year = {2015},
isbn = {9781450335423},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2785956.2790038},
doi = {10.1145/2785956.2790038},
booktitle = {Proceedings of the 2015 ACM Conference on Special Interest Group on Data Communication},
pages = {371–372},
numpages = {2},
location = {London, United Kingdom},
series = {SIGCOMM '15}
}
@article{PBEExcel,
  title={Spreadsheet data manipulation using examples},
  author={Gulwani, Sumit and Harris, William R and Singh, Rishabh},
  journal={Communications of the ACM},
  volume={55},
  number={8},
  pages={97--105},
  year={2012},
  publisher={ACM New York, NY, USA}
}
@article{ExceptionHandling,
  author    = {John B. Goodenough},
  title     = {Exception Handling: Issues and a Proposed Notation},
  journal   = {Commun. {ACM}},
  volume    = {18},
  number    = {12},
  pages     = {683--696},
  year      = {1975},
  url       = {https://doi.org/10.1145/361227.361230},
  doi       = {10.1145/361227.361230},
  timestamp = {Wed, 09 Oct 2019 16:39:06 +0200},
  biburl    = {https://dblp.org/rec/journals/cacm/Goodenough75.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@book{HumanError,
  title={Human error},
  author={Reason, James},
  year={1990},
  publisher={Cambridge university press}
}
@online{BretVictor,
url = {http://worrydream.com/#!/LearnableProgramming},
author = {Bret Victor},
year = 2012,
title = {Learnable Programming},
}
@inproceedings{AspectJ,
  author    = {Gregor Kiczales and
               Erik Hilsdale and
               Jim Hugunin and
               Mik Kersten and
               Jeffrey Palm and
               William G. Griswold},
  editor    = {J{\o}rgen Lindskov Knudsen},
  title     = {An Overview of {AspectJ}},
  booktitle = {{ECOOP} 2001 - Object-Oriented Programming, 15th European Conference,
               Budapest, Hungary, June 18-22, 2001, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {2072},
  pages     = {327--353},
  publisher = {Springer},
  year      = {2001},
  url       = {https://doi.org/10.1007/3-540-45337-7\_18},
  doi       = {10.1007/3-540-45337-7\_18},
  timestamp = {Tue, 14 May 2019 10:00:54 +0200},
  biburl    = {https://dblp.org/rec/conf/ecoop/KiczalesHHKPG01.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@article{CogDims,
    author = {T. R. G. Green and M. Petre},
    title = {Usability Analysis of Visual Programming Environments: a `cognitive dimensions' framework},
    journal = {JOURNAL OF VISUAL LANGUAGES AND COMPUTING},
    year = {1996},
    volume = {7},
    pages = {131--174}
}
@inproceedings{Pygmalion,
  title={Pygmalion: a creative programming environment.},
  author={D. C. Smith},
  year={1975}
}
glide
@inproceedings{SnS,
author = {Hempel, Brian and Lubin, Justin and Chugh, Ravi},
title = {{Sketch-n-Sketch}: Output-Directed Programming for {SVG}},
year = {2019},
isbn = {9781450368162},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3332165.3347925},
doi = {10.1145/3332165.3347925},
abstract = {For creative tasks, programmers face a choice: Use a GUI and sacrifice flexibility, or write code and sacrifice ergonomics?To obtain both flexibility and ease of use, a number of systems have explored a workflow that we call output-directed programming. In this paradigm, direct manipulation of the program's graphical output corresponds to writing code in a general-purpose programming language, and edits not possible with the mouse can still be enacted through ordinary text edits to the program. Such capabilities provide hope for integrating graphical user interfaces into what are currently text-centric programming environments.To further advance this vision, we present a variety of new output-directed techniques that extend the expressive power of Sketch-n-Sketch, an output-directed programming system for creating programs that generate vector graphics. To enable output-directed interaction at more stages of program construction, we expose intermediate execution products for manipulation and we present a mechanism for contextual drawing. Looking forward to output-directed programming beyond vector graphics, we also offer generic refactorings through the GUI, and our techniques employ a domain-agnostic provenance tracing scheme.To demonstrate the improved expressiveness, we implement a dozen new parametric designs in Sketch-n-Sketch without text-based edits. Among these is the first demonstration of building a recursive function in an output-directed programming setting.},
booktitle = {Proceedings of the 32nd Annual ACM Symposium on User Interface Software and Technology},
pages = {281–292},
numpages = {12},
keywords = {svg, sketch-n-sketch, output-directed programming},
location = {New Orleans, LA, USA},
series = {UIST '19}
}
@book{HyperCard,
author = {Michel, Stephen L.},
title = {Hypercard: The Complete Reference},
address = {Berkeley},
publisher = {Osborne McGraw-Hill},
year = 1989,
}
@phdthesis{Pilot,
title = {PILOT: A Step Toward Man-Computer Symbiosis},
author = {Warren Teitelman},
year = 1966,
publisher = {MIT}
}
@inproceedings{OAP,
  title={The Open Authorial Principle: Supporting Networks of Authors in Creating Externalisable Designs},
  author={Basman, Antranig and Lewis, Clayton and Clark, Colin},
  booktitle={Proceedings of the 2018 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
  pages={29--43},
  year={2018}
}
inproceedings{ComplementaryBasic,
  title={Complementary science of interactive programming systems},
  author={Tomas Petricek and Joel Jakubovic},
  booktitle={History and Philosophy of Computing},
  year={2021}
}
@phdthesis{TcherDiss,
    title={Designing and Programming Malleable Software},
    author={Tchernavskij, Philip},
    year={2019},
    school={Université Paris-Saclay, École doctorale nº580 Sciences et Technologies de l'Information et de la Communication (STIC)},
    type={PhD thesis}
}
coda
@InProceedings{Hazel17,
  author =	{Cyrus Omar and Ian Voysey and Michael Hilton and Joshua Sunshine and Claire Le Goues and Jonathan Aldrich and Matthew A. Hammer},
  title =	{{Toward Semantic Foundations for Program Editors}},
  booktitle =	{2nd Summit on Advances in Programming Languages (SNAPL 2017)},
  pages =	{11:1--11:12},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-032-3},
  ISSN =	{1868-8969},
  year =	{2017},
  volume =	{71},
  editor =	{Benjamin S. Lerner and Rastislav Bod{\'i}k and Shriram Krishnamurthi},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2017/7127},
  URN =		{urn:nbn:de:0030-drops-71273},
  doi =		{10.4230/LIPIcs.SNAPL.2017.11},
  annote =	{Keywords: program editors, type systems, live programming, program prediction}
}
vlhcc
live
px
@inproceedings{Liveness,
author = {Tanimoto, Steven L.},
title = {A Perspective on the Evolution of Live Programming},
year = {2013},
isbn = {9781467362658},
publisher = {IEEE Press},
abstract = {Liveness in programming environments generally refers to the ability to modify a running program. Liveness is one form of a more general class of behaviors by a programming environment that provide information to programmers about what they are constructing. This paper gives a brief historical perspective on liveness and proposes an extension of a hierarchy given in 1990, to now account for even more powerful execution-oriented tools for programmers. In addition, while liveness concerns the timeliness of execution feedback, considering a broader array of forms of feedback is helpful both in better understanding liveness and in designing ever more powerful development tools.},
booktitle = {Proceedings of the 1st International Workshop on Live Programming},
pages = {31–34},
numpages = {4},
keywords = {live coding, software engineering, live programming, tactical prediction, liveness levels, code completion, liveness, program inference, debugging, integrated development environment, software development tools, strategic prediction},
location = {San Francisco, California},
series = {LIVE '13}
}
@book{DesPats,
author = {Erich Gamma and Richard Helm and Ralph E. Johnson and John Vlissides},
title = {Design Patterns: Elements of Reusable Object-Oriented Software},
address = {Reading, Mass},
publisher = {Addison-Wesley},
year = 1995,
}
@inproceedings{EvProgSys,
  author    = {Jonathan Edwards and Stephen Kell and
               Tomas Petricek and Luke Church},
  title     = {Evaluating programming systems design},
  booktitle = {Proceedings of 30th Annual Workshop of
               Psychology of Programming Interest Group},
  series    = {PPIG 2019},
  location  = {Newcastle, UK},
  year      = {2019}
}
@inproceedings{EvUISR,
author = {Olsen, Dan R.},
title = {Evaluating User Interface Systems Research},
year = {2007},
isbn = {9781595936790},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1294211.1294256},
doi = {10.1145/1294211.1294256},
abstract = {The development of user interface systems has languished with the stability of desktop computing. Future systems, however, that are off-the-desktop, nomadic or physical in nature will involve new devices and new software systems for creating interactive applications. Simple usability testing is not adequate for evaluating complex systems. The problems with evaluating systems work are explored and a set of criteria for evaluating new UI systems work is presented.},
booktitle = {Proceedings of the 20th Annual ACM Symposium on User Interface Software and Technology},
pages = {251–258},
numpages = {8},
keywords = {user interface systems evaluation},
location = {Newport, Rhode Island, USA},
series = {UIST '07}
}
@online{OlsenCheat,
url = {https://people.cs.uchicago.edu/~brianhempel/Evaluating%20User%20Interface%20Systems%20Research%20-%20Graphical%20Summary.pdf},
author = {Brian Hempel},
year = {2018},
title = {Evaluating User Interface Systems Research (Summary / Cheat Sheet)},
}
@book{Chang,
author = {Chang, Hasok},
year = 2004,
title = {Inventing temperature: Measurement and scientific progress},
publisher = {Oxford University Press},
address = {Oxford},
}
@book{Norman,
author = {Norman, Donald A.},
title = {The Design of Everyday Things},
year = {2002},
isbn = {9780465067107},
publisher = {Basic Books, Inc.},
address = {USA},
abstract = {Revealing how smart design is the new competitive frontier, this innovative book is a powerful primer on how--and why--some products satisfy customers while others only frustrate them.}
}
@article{Alg58,
author = {Perlis, Alan J. and Samelson, K.},
title = {Preliminary Report: International Algebraic Language},
year = {1958},
issue_date = {Dec. 1958},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/377924.594925},
doi = {10.1145/377924.594925},
journal = {Commun. ACM},
month = dec,
pages = {8–22},
numpages = {15},
}
@online{Live13,
url = {http://davidungar.net/Live2013/Live_2013.html},
title = {The thing on the screen is supposed to be the actual thing},
author = {Ungar, David and Smith, Randall B.},
year = 2013,
}

@online{UISTAuthor,
url = {https://uist.acm.org/uist2021/author-guide.html},
title = {UIST 2021 - Author Guide},
author = {Kumar, Ranjitha and Nebeling, Michael},
year = 2021,
}

projedit
@book{PaperTools,
author = {Klein, Ursula},
title = {Experiments, Models, Paper Tools: Cultures of Organic Chemistry in the Nineteenth Century},
publisher = {Stanford University Press},
year = 2003,
isbn = 9780804743594,
address = {Stanford, CA},
url = {http://www.sup.org/books/title/?id=1917}
}
@online{WIB,
url = {https://www.dreamsongs.com/WorseIsBetter.html},
author = {Gabriel, Richard P.},
title = {Worse Is Better},
year = 1991,
}
@online{Perl,
title = {Perl, the first postmodern computer language},
url = {http://www.wall.org//~larry/pm.html},
author = {Larry Wall},
year = 1999,
}
@online{STdesign,
  title = {Design Principles Behind {Smalltalk}},
  url = {https://archive.org/details/byte-magazine-1981-08/page/n299/mode/2up},
  year = 1981,
  author = {Daniel Ingalls},
}
@article{Euphemism,
url = {http://web.stanford.edu/class/cs99r/readings/parnas1.pdf},
title = {Software Aspects of Strategic Defense Systems},
year = 1985,
author = {David Lorge Parnas},
}
@inproceedings{NextGen,
author = {Smaragdakis, Yannis},
title = {Next-Paradigm Programming Languages: What Will They Look like and What Changes Will They Bring?},
year = {2019},
isbn = {9781450369954},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3359591.3359739},
doi = {10.1145/3359591.3359739},
abstract = {The dream of programming language design is to bring about orders-of-magnitude productivity improvements in software development tasks. Designers can endlessly debate on how this dream can be realized and on how close we are to its realization. Instead, I would like to focus on a question with an answer that can be, surprisingly, clearer: what will be the common principles behind next-paradigm, high-productivity programming languages, and how will they change everyday program development? Based on my decade-plus experience of heavy-duty development in declarative languages, I speculate that certain tenets of high-productivity languages are inevitable. These include, for instance, enormous variations in performance (including automatic transformations that change the asymptotic complexity of algorithms); a radical change in a programmer's workflow, elevating testing from a near-menial task to an act of deep understanding; and a change in the need for formal proofs.},
booktitle = {Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {187–197},
numpages = {11},
keywords = {next-paradigm programming languages, programming paradigms},
location = {Athens, Greece},
series = {Onward! 2019}
}
@online{LispCurse,
url = {http://www.winestockwebdesign.com/Essays/Lisp_Curse.html},
title = {The {Lisp} Curse},
author = {Rudolf Winestock},
year = {2011},
}
@incollection{brooks95aristo,
  title={Aristocracy, Democracy and System Design},
  author={Brooks, FP},
  booktitle={The Mythical Man Month: Essays on Software Engineering},
  year={1995},
  publisher={Addison-Wesley}
}
@inproceedings{DesignedAsDesigner,
author = {Gabriel, Richard P.},
title = {Designed as Designer},
year = {2008},
isbn = {9781605582153},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1449764.1449813},
doi = {10.1145/1449764.1449813},
abstract = {Conceptual integrity arises not (simply) from one mind or from a small number of agreeing
resonant minds, but from sometimes hidden co-authors and the thing designed itself.},
booktitle = {Proceedings of the 23rd ACM SIGPLAN Conference on Object-Oriented Programming Systems Languages and Applications},
pages = {617–632},
numpages = {16},
keywords = {conceptual integrity, design},
location = {Nashville, TN, USA},
series = {OOPSLA '08}
}
@inproceedings{LispEvolve,
author = {Steele, Guy L. and Gabriel, Richard P.},
title = {The Evolution of {Lisp}},
year = {1993},
isbn = {0897915704},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/154766.155373},
doi = {10.1145/154766.155373},
booktitle = {The Second ACM SIGPLAN Conference on History of Programming Languages},
pages = {231–270},
numpages = {40},
location = {Cambridge, Massachusetts, USA},
series = {HOPL-II}
}
@article{ProgProgLang,
author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram and Barzilay, Eli and McCarthy, Jay and Tobin-Hochstadt, Sam},
title = {A Programmable Programming Language},
year = {2018},
issue_date = {March 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {61},
number = {3},
issn = {0001-0782},
url = {https://doi.org/10.1145/3127323},
doi = {10.1145/3127323},
abstract = {As the software industry enters the era of language-oriented programming, it needs
programmable programming languages.},
journal = {Commun. ACM},
month = {02},
pages = {62–71},
numpages = {10}
}
@article{LispIntro,
author = {Foderaro, John},
title = {LISP: Introduction},
year = {1991},
issue_date = {Sept. 1991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {34},
number = {9},
issn = {0001-0782},
url = {https://doi.org/10.1145/114669.114670},
doi = {10.1145/114669.114670},
journal = {Commun. ACM},
month = sep,
pages = {27},
numpages = {1}
}
@book{LISP15,
author = {McCarthy, John},
title = {LISP 1.5 Programmer's Manual},
year = {1962},
isbn = {0262130114},
publisher = {The MIT Press}
}
@inproceedings{SocioPLT,
author = {Meyerovich, Leo A. and Rabkin, Ariel S.},
title = {Socio-{PLT}: Principles for Programming Language Adoption},
year = {2012},
isbn = {9781450315623},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2384592.2384597},
doi = {10.1145/2384592.2384597},
booktitle = {Proceedings of the ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {39–54},
numpages = {16},
keywords = {sociology, history, programming language adoption},
location = {Tucson, Arizona, USA},
series = {Onward! 2012}
}
@online{WhatIsSuccess,
url = {https://www.youtube.com/watch?v=uGlzRt-FYto},
author = {Evan Czaplicki},
year = {2018},
}
@article{FullBrain,
author = {Fry, Christopher},
title = {Programming on an Already Full Brain},
year = {1997},
issue_date = {April 1997},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {4},
issn = {0001-0782},
url = {https://doi.org/10.1145/248448.248459},
doi = {10.1145/248448.248459},
journal = {Commun. ACM},
month = {04},
pages = {55–64},
numpages = {10}
}
@book{MMM,
author = {Brooks, Frederick P.},
title = {The  Mythical Man-Month: Essays on Softw},
year = {1978},
isbn = {0201006502},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA},
edition = {1st}
}
@article{PoMoProNotes,
author = {Noble, James and Biddle, Robert},
title = {Notes on Notes on Postmodern Programming},
year = {2004},
issue_date = {December 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/1052883.1052890},
doi = {10.1145/1052883.1052890},
journal = {SIGPLAN Not.},
month = {12},
pages = {40–56},
numpages = {17},
keywords = {object-oriented design, object-oriented programming}
}
@inproceedings{Wildcard,
author = {Litt, Geoffrey and Jackson, Daniel and Millis, Tyler and Quaye, Jessica},
title = {End-User Software Customization by Direct Manipulation of Tabular Data},
year = {2020},
isbn = {9781450381789},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3426428.3426914},
doi = {10.1145/3426428.3426914},
booktitle = {Proceedings of the 2020 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {18–33},
numpages = {16},
keywords = {browser extensions, web automation, end user programming, spreadsheets, software customization},
location = {Virtual, USA},
series = {Onward! 2020}
}
@online{APIdesign,
title = {How to Design a Good {API} and Why it Matters},
url = {http://www.cs.bc.edu/~muller/teaching/cs102/s06/lib/pdf/api-design},
author = {Joshua Bloch},
year = "2007",
}
@phdthesis{Hancock2003,
  author = {C. Hancock and M. Resnick},
  title  = {Real-time programming and the big ideas of computational literacy},
  year   = {2003},
  school = {Massachusetts Institute of Technology},
  url    = {https://dspace.mit.edu/handle/1721.1/61549}
}
@online{Infusion,
  title  = {Infusion Framework and Components},
  url    = {https://fluidproject.org/infusion.html},
  author = {Antranig Basman},
  year   = {2021}
}
@article{PersonalDynMedia,
  author={Alan Kay and Adele Goldberg},
  journal={Computer},
  title={Personal Dynamic Media},
  year={1977},
  volume={10},
  number={3},
  pages={31-41},
  doi={10.1109/C-M.1977.217672}
}
@phdthesis{NakedObjects,
    title={Naked Objects},
    author={Pawson, Richard},
    year={2004},
    school={Trinity College, University of Dublin},
    type={PhD thesis}
}
@article{LiterateProg,
  title={Literate programming},
  author={Knuth, Donald Ervin},
  journal={The computer journal},
  volume={27},
  number={2},
  pages={97--111},
  year={1984},
  publisher={Oxford University Press}
}
@inproceedings{TedNelson,
author = {Nelson, T. H.},
title = {Complex Information Processing: A File Structure for the Complex, the Changing and the Indeterminate},
year = {1965},
isbn = {9781450374958},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800197.806036},
doi = {10.1145/800197.806036},
abstract = {THE KINDS OF FILE structures required if we are to use the computer for personal files and as an adjunct to creativity are wholly different in character from those customary in business and scientific data processing. They need to provide the capacity for intricate and idiosyncratic arrangements, total modifiability, undecided alternatives, and thorough internal documentation.I want to explain how some ideas developed and what they are. The original problem was to specify a computer system for personal information retrieval and documentation, able to do some rather complicated things in clear and simple ways.In this paper I will explain the original problem. Then I will explain why the problem is not simple, and why the solution (a file structure) must yet be very simple. The file structure suggested here is the Evolutionary List File, to be built of zippered lists. A number of uses will be suggested for such a file, to show the breadth of its potential usefulness. Finally, I want to explain the philosophical implications of this approach for information retrieval and data structure in a changing world.},
booktitle = {Proceedings of the 1965 20th National Conference},
pages = {84–100},
numpages = {17},
location = {Cleveland, Ohio, USA},
series = {ACM '65}
}
@article{DirectManip,
author={Shneiderman},
journal={Computer},
title={Direct Manipulation: A Step Beyond Programming Languages},
year={1983},
volume={16},
number={8},
pages={57-69},
doi={10.1109/MC.1983.1654471}
}
@inproceedings{NotYetCraft,
  author    = {Antranig Basman},
  editor    = {Luke Church},
  title     = {Building Software is Not (Yet) a Craft},
  booktitle = {Proceedings of the 27th Annual Workshop of the Psychology of Programming
               Interest Group, {PPIG} 2016, Cambridge, UK, September 7-10, 2016},
  pages     = {32},
  publisher = {Psychology of Programming Interest Group},
  year      = {2016},
  url       = {http://ppig.org/library/paper/building-software-not-yet-craft},
  timestamp = {Tue, 16 Mar 2021 16:24:00 +0100},
  biburl    = {https://dblp.org/rec/conf/ppig/Basman16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

 @book{Cathedral,
  title     = {The Cathedral \& The Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary},
  publisher = {O'Reilly},
  author    = {Raymond, Eric S. and Young, Bob},
  year      = {2001}
}

@book{DSLs,
  title={Domain-specific languages},
  author={Fowler, Martin},
  year={2010},
  publisher={Pearson Education}
}

@book{SwStudies,
  title={Software studies: A lexicon},
  author={Fuller, Matthew and others},
  year={2008},
  publisher={Mit Press}
}

@software{CodaWeb,
  url = {https://coda.io},
  title = {Coda: The doc that brings it all together},
  date = {2022-05-23},
  author = {Coda}
}

@software{ReplitWeb,
  url = {https://replit.com},
  title = {Replit: The collaborative browser-based {IDE}},
  date = {2022-05-23},
  author = {repl.it}
}

@software{DarkWeb,
  url = {https://darklang.com},
  title = {Dark Lang},
  date = {2022-05-23},
  author = {{Dark Language Team}}
}

@software{GlideWeb,
  url = {https://www.glideapps.com},
  title = {Glide: Create apps and websites without code},
  date = {2022-05-23},
  author = {Glide}
}

@software{LSP,
  url = {https://microsoft.github.io/language-server-protocol/},
  title = {Language Server Protocol},
  date = {2022-05-23},
  author = {Microsoft}
}

@article{SPEPrograms,
  title={Programs, life cycles, and laws of software evolution},
  author={Lehman, Meir M},
  journal={Proceedings of the IEEE},
  volume={68},
  number={9},
  pages={1060--1076},
  year={1980},
  publisher={IEEE}
}
@online{DarkErrors,
  author = {Ellen Chisa},
  title = {Introduction: Error Rail and Match with \texttt{DB::get}},
  year = {2020},
  url = {https://youtu.be/NRMmy9ZzA-o}
}
@article{LabView,
author = {Kodosky, Jeffrey},
title = {Lab{VIEW}},
year = {2020},
issue_date = {June 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {HOPL},
url = {https://doi.org/10.1145/3386328},
doi = {10.1145/3386328},
abstract = {LabVIEW™ is unusual among programming languages in that we did not intend to create a new language but rather to develop a tool for non-programmer scientists and engineers to assist them in automating their test and measurement systems. Prior experience creating software for controlling instruments led us to the perspective that the software ought to be modeled as a hierarchy of ”virtual instruments”. The lowest level virtual instruments were simply reflections of the individual physical instruments they controlled. Higher level virtual instruments combined lower level ones to deliver more complex measurements. A frequency response virtual instrument could be implemented using a voltmeter and a sine-wave generator inside a loop that stepped through a frequency range. This was mostly an abstract concept at the time because it was hard to imagine how an existing language or tool could provide the rich yet intuitive experience of using a real instrument. Inspired by the first Macintosh computer, we quickly realized the graphical user interface would be a natural way to interact with a virtual instrument, but it also sparked our imaginations about using graphics for creating software at a higher level of abstraction. The February 1982 issue of IEEE Computer was devoted to data-flow models of computation, and it convinced us that graphical data-flow diagrams needed to be part of the solution. The major difficulty we saw, however, was the need to use cycles in the data-flow diagram to represent loops. Cycles increased complexity and made diagrams hard to understand and even harder to create. This concern led to a major innovation in creating LabVIEW: merging structured programming concepts with data-flow. We represented control-flow structures as boxes in a data-flow diagram. We knew how to reason about loops, so we could introduce them as first class elements of the graphical representation rather than being constructed from lower-level elements. A box could encapsulate the semantics of the iterative behavior; it could clearly separate the body of the loop (the diagram inside the box) from the code before and after the loop (the diagram outside the box); and, its boundary could hold iteration state information. Those fundamental concepts of ”graphical”, ”structured” and ”data-flow” enabled us to propose a software product. We staffed up a small skunkworks team to implement it. We called it LabVIEW. It was to be an engineer’s tool for automating measurement systems. At first, we were reluctant to admit that we had created a graphical programming language. When we finally did, we nicknamed it G, for Graphical language, so we could talk about the language as distinct from the integrated development environment (IDE), LabVIEW. In practice, almost everyone refers to both the language and the IDE as LabVIEW. Without intending to do so, we created a programming language radically different from those that came before, pioneering techniques of graphically creating and viewing code, eliminating manual memory management without adding garbage collection overhead, and anticipating the massively parallel systems of the modern era. LabVIEW continues to evolve and thrive after more than 30 years.},
journal = {Proc. ACM Program. Lang.},
month = {06},
articleno = {78},
numpages = {54},
keywords = {LabVIEW, data flow language, graphical programming}
}
@book{Java,
  title={The Java language specification},
  author={Gosling, James and Joy, Bill and Steele, Guy and Bracha, Gilad},
  year={2000},
  publisher={Addison-Wesley Professional}
}
@article{Eclipse,
  author={desRivieres, J. and Wiegand, J.}, 
  journal={IBM Systems Journal},
  title={Eclipse: A platform for integrating development tools},
  year={2004},
  volume={43},
  number={2},
  pages={371-383},
  doi={10.1147/sj.432.0371}
}
@book{GHC,
  title={The Glasgow Haskell Compiler},
  author={Simon Marlow and Simon Peyton-Jones},
  chapter=5,
  booktitle={The Architecture of Open Source Applications, Volume II},
  editor={Brown, A. and Wilson, G.},
  isbn={9781105571817},
  series={The Architecture of Open Source Applications},
  url={http://www.aosabook.org},
  year={2012},
  publisher={CreativeCommons}
}
@article{Jupyter,
  title={Jupyter Notebooks—a publishing format for reproducible computational workflows},
  author={Kluyver, Thomas and Ragan-Kelley, Benjamin and P{\'e}rez, Fernando and Granger, Brian and Bussonnier, Matthias and Frederic, Jonathan and Kelley, Kyle and Hamrick, Jessica and Grout, Jason and Corlay, Sylvain and others},
  journal={Positioning and Power in Academic Publishing: Players, Agents and Agendas},
  pages={87},
  year={2016},
}
@book{Mathematica,
author = {Wolfram, Stephen},
title = {Mathematica: A System for Doing Mathematics by Computer (2nd Ed.)},
year = {1991},
isbn = {0201515075},
publisher = {Addison Wesley Longman Publishing Co., Inc.},
address = {USA}
}
@book{CommonLisp,
  title={Common LISP: The Language},
  author={Steele, G. and Fahlman, S.E.},
  isbn={9781555580414},
  lccn={89026016},
  series={HP Technologies},
  url={https://books.google.cz/books?id=FYoOIWuoXUIC},
  year={1990},
  publisher={Elsevier Science}
}
@book{Hackers,
author = {Levy, Steven},
title = {Hackers: Heroes of the Computer Revolution},
year = {1984},
isbn = {0385191952},
publisher = {Doubleday},
address = {USA}
}
@book{DotCom,
author = {Ankerson, Megan Sapnar},
title = {Dot-Com Design: The Rise of a Usable, Social, Commercial Web},
year = {2018},
isbn = {1479892904},
publisher = {NYU Press},
abstract = {From dial-up to wi-fi, an engaging cultural history of the commercial web industry In the 1990s, the World Wide Web helped transform the Internet from the domain of computer scientists to a playground for mass audiences. As URLs leapt off computer screens and onto cereal boxes, billboards, and film trailers, the web changed the way many Americans experienced media, socialized, and interacted with brands. Businesses rushed online to set up corporate home pages and as a result, a new cultural industry was born: web design. For todays internet users who are more familiar sharing social media posts than collecting hotlists of cool sites, the early web may seem primitive, clunky, and graphically inferior. After the dot-com bubble burst in 2000, this pre-crash era was dubbed Web 1.0, a retronym meant to distinguish the early web from the social, user-centered, and participatory values that were embodied in the internet industrys resurgence as Web 2.0 in the 21st century. Tracking shifts in the rules of good web design, Ankerson reimagines speculation and design as a series of contests and collaborations to conceive the boundaries of a new digitally networked future. What was it like to go online and surf the Web in the 1990s? How and why did the look and feel of the web change over time? How do new design paradigms like user-experience design (UX) gain traction? Bringing together media studies, internet studies, and design theory, Dot-com Design traces the shifts in, and struggles over, the webs production, aesthetics, and design to provide a comprehensive look at the evolution of the web industry and into the vast internet we browse today.}
}
@article{VisiCalc,
  author={Grad, Burton},
  journal={IEEE Annals of the History of Computing},
  title={The Creation and the Demise of {VisiCalc}},
  year={2007},
  volume={29},
  number={3},
  pages={20-31},
  doi={10.1109/MAHC.2007.4338439}
}
@article{VisiCalc2,
author = {Zynda, Melissa Rodriguez},
title = {The First Killer App: A History of Spreadsheets},
year = {2013},
issue_date = {September + October 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {20},
number = {5},
issn = {1072-5520},
url = {https://doi.org/10.1145/2509224},
doi = {10.1145/2509224},
abstract = {Timelines provides perspectives on HCI history, glancing back at a road that sometimes took unexpected branches and turns. History is not a dry list of events; it is about points of view and differing interpretations.---Jonathan Grudin, Editor},
journal = {Interactions},
month = {09},
pages = {68–72},
numpages = {5}
}
@online{LIVE,
title = {{LIVE} Workshops},
url = {https://liveprog.org/},
author = {{LIVE}},
year = 2023,
}
@online{LIVE20,
  title = {{LIVE} Workshop 2020},
  url = {https://liveprog.org/live-2020/},
  author = {Brian Hempel and Roly Perera},
  year = 2020,
}
@online{LIVE21,
  title = {{LIVE} Workshop 2021},
  url = {https://liveprog.org/live-2021/},
  author = {Brian Hempel and Sam Lau},
  year = 2021,
}
@online{PX,
  title = {Programming Experience (PX) Workshops},
  url = {http://programming-experience.org/},
  author = {{PX}},
  year = {2023},
}
article{TechDims,
	doi = {10.22152/programming-journal.org/2023/7/13},
	year = 2023,
	month = {02},
	publisher = {Aspect-Oriented Software Association ({AOSA})},
	volume = {7},
	number = {3},
	author = {Joel Jakubovic and Jonathan Edwards and Tomas Petricek},
	title = {Technical Dimensions of Programming Systems},
	journal = {The Art, Science, and Engineering of Programming}
}
@book{Kuhn,
  author = {Kuhn, Thomas S.},
  booktitle = {The Structure of Scientific Revolutions},
  publisher = {University of Chicago Press},
  year = 1970
}
@ARTICLE{AiryTape,
  author={Campbell-Kelly, M.},
  journal={IEEE Annals of the History of Computing}, 
  title={The Airy tape: an early chapter in the history of debugging}, 
  year={1992},
  volume={14},
  number={4},
  pages={16-26},
  doi={10.1109/85.194051}
}
@book{WilkesMemoir,
author = {Wilkes, Maurice},
title = {Memoirs of a Computer Pioneer},
year = {1985},
isbn = {0262231220},
publisher = {Massachusetts Institute of Technology},
address = {USA}
}
@book{NewHistory,
  author = {Tomas Haigh and Paul E. Ceruzzi},
  title = {A New History of Modern Computing},
  isbn = {9780262542906},
  year = {2021},
  publisher = {The MIT Press},
  address = {USA}
}
@inproceedings{10.1145/38765.38821,
author = {Maes, Pattie},
title = {Concepts and Experiments in Computational Reflection},
year = {1987},
isbn = {0897912470},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/38765.38821},
doi = {10.1145/38765.38821},
abstract = {This paper brings some perspective to various concepts in computational reflection. A definition of computational reflection is presented, the importance of computational reflection is discussed and the architecture of languages that support reflection is studied. Further, this paper presents a survey of some experiments in reflection which have been performed. Examples of existing procedural, logic-based and rule-based languages with an architecture for reflection are briefly presented. The main part of the paper describes an original experiment to introduce a reflective architecture in an object-oriented language. It stresses the contributions of this language to the field of object-oriented programming and illustrates the new programming style made possible. The examples show that a lot of programming problems that were previously handled on an ad hoc basis, can in a reflective architecture be solved more elegantly.},
booktitle = {Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications},
pages = {147–155},
numpages = {9},
location = {Orlando, Florida, USA},
series = {OOPSLA '87}
}
@article{CompRefl,
author = {Maes, Pattie},
title = {Concepts and Experiments in Computational Reflection},
year = {1987},
issue_date = {Dec. 1987},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {22},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/38807.38821},
doi = {10.1145/38807.38821},
abstract = {This paper brings some perspective to various concepts in computational reflection. A definition of computational reflection is presented, the importance of computational reflection is discussed and the architecture of languages that support reflection is studied. Further, this paper presents a survey of some experiments in reflection which have been performed. Examples of existing procedural, logic-based and rule-based languages with an architecture for reflection are briefly presented. The main part of the paper describes an original experiment to introduce a reflective architecture in an object-oriented language. It stresses the contributions of this language to the field of object-oriented programming and illustrates the new programming style made possible. The examples show that a lot of programming problems that were previously handled on an ad hoc basis, can in a reflective architecture be solved more elegantly.},
journal = {SIGPLAN Not.},
month = {12},
pages = {147–155},
numpages = {9}
}
@online{Polyglot,
  url = {http://memeagora.blogspot.com/2006/12/polyglot-programming.html},
  title = {Polyglot Programming},
  year = {2006},
  author = {Neal Ford}
}
@online{Metac,
  url = {https://wiki.c2.com/?MetaCircularEvaluator},
  title = {Meta-circular Evaluator},
  year = {2012},
  author = {{C2 Contributors}}
}
@book{Cprog,
author = {Kernighan, Brian W. and Ritchie, Dennis M.},
title = {The C Programming Language},
year = {1989},
isbn = {0131103628},
publisher = {Prentice Hall Press},
address = {USA},
abstract = {This ebook is the first authorized digital version of Kernighan and Ritchies 1988 classic, The C Programming Language (2nd Ed.). One of the best-selling programming books published in the last fifty years, K&amp;R has been called everything from the bible to a landmark in computer science and it has influenced generations of programmers. Available now for all leading ebook platforms, this concise and beautifully written text is a must-have reference for every serious programmers digital library. As modestly described by the authors in the Preface to the First Edition, this is not an introductory programming manual; it assumes some familiarity with basic programming concepts like variables, assignment statements, loops, and functions. Nonetheless, a novice programmer should be able to read along and pick up the language, although access to a more knowledgeable colleague will help.}
}
@inproceedings{MPS,
author = {Voelter, Markus and Pech, Vaclav},
title = {Language Modularity with the MPS Language Workbench},
year = {2012},
isbn = {9781467310673},
publisher = {IEEE Press},
abstract = {JetBrains MPS is a comprehensive environment for language engineering. New languages can be defined as standalone languages or as modular extensions of existing languages. Since MPS is a projectional editor, syntactic forms other than text are possible, including tables or mathematical symbols. This demo will show MPS based on mbeddr C, a novel approach for embedded software development that makes use of incremental language extension on the basis of C.},
booktitle = {Proceedings of the 34th International Conference on Software Engineering},
pages = {1449–1450},
numpages = {2},
location = {Zurich, Switzerland},
series = {ICSE '12}
}
@online{SelfOutliner,
url = {https://blog.rfox.eu/en/Programming/Series_about_Self/Environment_and_the_programming_language_Self_part_one_environment.html},
title = {Environment and the Programming Language Self (part one; environment)},
year = {2019},
author = {Anon Bystroushaak},
}
@inproceedings{Self,
author = {Ungar, David and Smith, Randall B.},
title = {Self},
year = {2007},
isbn = {9781595937667},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1238844.1238853},
doi = {10.1145/1238844.1238853},
abstract = {The years 1985 through 1995 saw the birth and development of the language Self, starting from its design by the authors at Xerox PARC, through first implementations by Ungar and his graduate students at Stanford University, and then with a larger team formed when the authors joined Sun Microsystems Laboratories in 1991. Self was designed to help programmers become more productive and creative by giving them a simple, pure, and powerful language, an implementation that combined ease of use with high performance, a user interface that off-loaded cognitive burden, and a programming environment that captured the malleability of a physical world of live objects. Accomplishing these goals required innovation in several areas: a simple yet powerful prototype-based object model for mainstream programming, many compilation techniques including customization, splitting, type prediction, polymorphic inline caches, adaptive optimization, and dynamic deoptimization, the application of cartoon animation to enhance the legibility of a dynamic graphical interface, an object-centered programming environment, and a user-interface construction framework that embodied a uniform use-mention distinction. Over the years, the project has published many papers and released four major versions of Self.Although the Self project ended in 1995, its implementation, animation, user interface toolkit architecture, and even its prototype object model impact computer science today (2006). Java virtual machines for desktop and laptop computers have adopted Self's implementation techniques, many user interfaces incorporate cartoon animation, several popular systems have adopted similar interface frameworks, and the prototype object model can be found in some of today's languages, including JavaScript. Nevertheless, the vision we tried to capture in the unified whole has yet to be achieved.},
booktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
pages = {9–1–9–50},
keywords = {Self, adaptive optimization, cartoon animation, dynamic language, dynamic optimization, exploratory programming, history of programming languages, morphic, object-oriented language, programming environment, prototype-based programming language, virtual machine},
location = {San Diego, California},
series = {HOPL III}
}
@inproceedings{PolyConstraints,
author = {Weiher, Marcel and Hirschfeld, Robert},
title = {Constraints as Polymorphic Connectors},
year = {2016},
isbn = {9781450339957},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2889443.2889456},
doi = {10.1145/2889443.2889456},
abstract = {The architecture of interactive systems does not match the procedural decomposition mechanisms available in most programming languages, leading to architectural mismatch. Constraint systems have been used only as black boxes for computing with primitive values of a specific type and for specific domains such as user interface layouts or program compilation. We propose constraints as a general purpose architectural connector for both describing the large-scale structure of interactive systems and matching that description with the actual implementation.},
booktitle = {Proceedings of the 15th International Conference on Modularity},
pages = {134–145},
numpages = {12},
keywords = {Architecture, Connectors, Constraints, Polymorphism},
location = {M\'{a}laga, Spain},
series = {MODULARITY 2016}
}
@online{Hull,
title = {Hull: An alternative to shell that I'll never have time to implement},
author = {Martin Sústrik},
url = {https://250bpm.com/blog:153/},
year = {2019},
}
@inproceedings{Eco,
    author = {Diekmann, Lukas and Tratt, Laurence},
    title = {{Eco}: A language composition editor},
    booktitle = {Software Language Engineering (SLE)},
    year = {2014},
    month = Sep,
    publisher = {Springer},
    doi = {10.1007/978-3-319-11245-9_5},
    pages={82--101},
    url = {https://soft-dev.org/pubs/html/diekmann_tratt__eco_a_language_composition_editor/}
}
@online{EvSourcing,
title = {Event Sourcing},
author = {Martin Fowler},
year = {2005},
url = {https://martinfowler.com/eaaDev/EventSourcing.html},
}
@article{DynCodeEvol,
title = {Unrestricted and safe dynamic code evolution for Java},
journal = {Science of Computer Programming},
volume = {78},
number = {5},
pages = {481-498},
year = {2013},
note = {Special section: Principles and Practice of Programming in Java 2009/2010 \& Special section: Self-Organizing Coordination},
issn = {0167-6423},
doi = {https://doi.org/10.1016/j.scico.2011.06.005},
url = {https://www.sciencedirect.com/science/article/pii/S0167642311001456},
author = {Thomas Würthinger and Christian Wimmer and Lukas Stadler},
keywords = {Java, Virtual machine, Class hierarchy, Run-time evolution, Dynamic software updating, Safe dynamic updates},
abstract = {Dynamic code evolution is a technique to update a program while it is running. In an object-oriented language such as Java, this can be seen as replacing a set of classes by new versions. We modified an existing high-performance virtual machine to allow arbitrary changes to the definition of loaded classes. Besides adding and deleting fields and methods, we also allow any kind of changes to the class and interface hierarchy. Our approach focuses on increasing developer productivity during debugging, but can also be applied for updating of long-running applications. Changes can be applied at any point at which a Java program can be suspended. Our virtual machine is able to continue execution of old changed or deleted methods and also to access deleted static fields. A dynamic verification of the current state of the program ensures type safety of complex class hierarchy changes. However, the programmer still has to ensure that the semantics of the modified program are correct and that the new program version can start running from the state left behind by the old program version. The evaluation section shows that our modifications to the virtual machine have no negative performance impact on normal program execution. The in-place instance update algorithm is in many cases faster than a full garbage collection. Standard Java development environments automatically use the code evolution features of our modified virtual machine, so no additional tools are required.}
}
@INPROCEEDINGS{CompNotebooks,
  author={Lau, Sam and Drosos, Ian and Markel, Julia M. and Guo, Philip J.},
  booktitle={2020 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)}, 
  title={The Design Space of Computational Notebooks: An Analysis of 60 Systems in Academia and Industry}, 
  year={2020},
  volume={},
  number={},
  pages={1-11},
  doi={10.1109/VL/HCC50065.2020.9127201}}
}
@article{LitProg,
    author = {Knuth, D. E.},
    title = "{Literate Programming}",
    journal = {The Computer Journal},
    volume = {27},
    number = {2},
    pages = {97-111},
    year = {1984},
    month = {01},
    abstract = "{The author and his associates have been experimenting for the past several years with a programming language and documentation system called WEB. This paper presents WEB by example, and discusses why the new system appears to be an improvement over previous ones.}",
    issn = {0010-4620},
    doi = {10.1093/comjnl/27.2.97},
    url = {https://doi.org/10.1093/comjnl/27.2.97},
    eprint = {https://academic.oup.com/comjnl/article-pdf/27/2/97/981657/270097.pdf},
}
@article{Likert,
  author = {Likert, Rensis},
  year = {1932},
  title = {A technique for the measurement of attitudes},
  journal = {Archives of Psychology},
  volume = {22},
  number = {140},
  pages = {55}
}
@article{Plan9,
author = {Pike, Rob and Presotto, Dave and Thompson, Ken and Trickey, Howard and Winterbottom, Phil},
title = {The Use of Name Spaces in Plan 9},
year = {1993},
issue_date = {April 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {27},
number = {2},
issn = {0163-5980},
url = {https://doi.org/10.1145/155848.155861},
doi = {10.1145/155848.155861},
abstract = {Plan 9 is a distributed system built at the Computing Sciences Research Center of AT\&T Bell Laboratories over the last few years. Its goal is to provide a production-quality system for software development and general computation using heterogeneous hardware and minimal software. A Plan 9 system comprises CPU and file servers in a central location connected together by fast networks. Slower networks fan out to workstation-class machines that serve as user terminals. Plan 9 argues that given a few carefully implemented abstractions it is possible to produce a small operating system that provides support for the largest systems on a variety of architectures and networks. The foundations of the system are built on two ideas: a per-process name space and a simple message-oriented file system protocol.},
journal = {SIGOPS Oper. Syst. Rev.},
month = {4},
pages = {72–76},
numpages = {5}
}
@article{PAF,
  title={Processes as Files, USENIX Summer Conf},
  author={Killian, Tom},
  journal={Proc., Salt Lake City},
  year={1984}
}
@online{CookClay,
title={Self-Defined Object System},
author={Dan Cook},
year={2018},
url={https://www.cemetech.net/forum/viewtopic.php?p=270092#270092},
}
@InProceedings{Briar,
  author       = "Gleicher, Michael",
  title        = "Practical Issues in Graphical Constraints",
  booktitle    = "Proceedings PPCP-93: Workshop on Principle and Practice of Constraint Programming",
  month        = "4",
  year         = "1993",
  url          = "http://graphics.cs.wisc.edu/Papers/1993/Gle93a"
}
@online{GPP,
url={https://gameprogrammingpatterns.com/},
title={Game Programming Patterns},
author={Bob Nystrom},
year={2014}
}
@online{ECS,
url={https://en.wikipedia.org/wiki/Entity_component_system},
title={Entity Component System},
author={Wikipedia},
year={2023},
}
@inproceedings{CES,
  title={The Component Entity System for Virtual Environments},
  author={Ehrlich, Justin},
  year={2013},
  booktitle = {Proceedings of the International Conference on Computer Graphics and Virtual Reality CGVR'13},
  editor    = {Arabnia, Hamid R. and Deligiannidis, Leonidas and Solo, Ashu M. G.},
  url = {http://worldcomp-proceedings.com/proc/p2013/CGV3033.pdf},
}

@online{Greenspun10,
url={http://wiki.c2.com/?GreenspunsTenthRuleOfProgramming},
title={Greenspun's Tenth Rule},
year={2014},
author={{C2 Contributors}},
}
@online{StrucEd,
url={https://github.com/yairchu/awesome-structure-editors/},
title={Structural Code Editor Projects},
author={Yair Chuchem},
year={2023},
}
@article{SweImpact,
author = {Ryder, Barbara G. and Soffa, Mary Lou and Burnett, Margaret},
title = {The Impact of Software Engineering Research on Modern Programming Languages},
year = {2005},
issue_date = {October 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {4},
issn = {1049-331X},
url = {https://doi.org/10.1145/1101815.1101818},
doi = {10.1145/1101815.1101818},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {oct},
pages = {431–477},
numpages = {47},
keywords = {Software Engineering, Programming Languages}
}
@online{PythonNotorious,
author = {{Python Guide}},
year = {2016},
title = {The Hitchiker's Guide To Python},
url = {https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments},
}
@article{Gator,
author = {Geisler, Dietrich and Yoon, Irene and Kabra, Aditi and He, Horace and Sanders, Yinnon and Sampson, Adrian},
title = {Geometry types for graphics programming},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428241},
doi = {10.1145/3428241},
abstract = {In domains that deal with physical space and geometry, programmers need to track the coordinate systems that underpin a computation. We identify a class of geometry bugs that arise from confusing which coordinate system a vector belongs to. These bugs are not ruled out by current languages for vector-oriented computing, are difficult to check for at run time, and can generate subtly incorrect output that can be hard to test for.  We introduce a type system and language that prevents geometry bugs by reflecting the coordinate system for each geometric object. A value's geometry type encodes its reference frame, the kind of geometric object (such as a point or a direction), and the coordinate representation (such as Cartesian or spherical coordinates). We show how these types can rule out geometrically incorrect operations, and we show how to use them to automatically generate correct-by-construction code to transform vectors between coordinate systems. We implement a language for graphics programming, Gator, that checks geometry types and compiles to OpenGL's shading language, GLSL. Using case studies, we demonstrate that Gator can raise the level of abstraction for shader programming and prevent common errors without inducing significant annotation overhead or performance cost.},
journal = {Proc. ACM Program. Lang.},
month = {11},
articleno = {173},
numpages = {25},
keywords = {type systems, language design, geometry, computer graphics}
}
@online{PrimInstrucs,
url={https://programmingmadecomplicated.wordpress.com/2021/11/03/primitive-instructions-for-nested-trees/},
title={Primitive Instructions for Nested Trees},
year={2021},
author={Joel Jakubovic},
}
@article{Tarpit,
author = {Perlis, Alan J.},
title = {Special Feature: Epigrams on programming},
year = {1982},
issue_date = {September 1982},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/947955.1083808},
doi = {10.1145/947955.1083808},
journal = {SIGPLAN Not.},
month = {09},
pages = {7–13},
numpages = {7}
}
@inproceedings{SqueakDev,
author = {Ingalls, Dan and Kaehler, Ted and Maloney, John and Wallace, Scott and Kay, Alan},
title = {Back to the future: the story of Squeak, a practical Smalltalk written in itself},
year = {1997},
isbn = {0897919084},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/263698.263754},
doi = {10.1145/263698.263754},
abstract = {Squeak is an open, highly-portable Smalltalk implementation whose virtual machine is written entirely in Smalltalk, making it easy to. debug, analyze, and change. To achieve practical performance, a translator produces an equivalent C program whose performance is comparable to commercial Smalltalks.Other noteworthy aspects of Squeak include: a compact object format that typically requires only a single word of overhead per object; a simple yet efficient incremental garbage collector for 32-bit direct pointers; efficient bulk-mutation of objects; extensions of BitBlt to handle color of any depth and anti-aliased image rotation and scaling; and real-time sound and music synthesis written entirely in Smalltalk.},
booktitle = {Proceedings of the 12th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {318–326},
numpages = {9},
location = {Atlanta, Georgia, USA},
series = {OOPSLA '97}
}
@book{AlgebraProg,
author = {Bird, Richard and de Moor, Oege},
title = {Algebra of programming},
year = {1997},
isbn = {013507245X},
publisher = {Prentice-Hall, Inc.},
address = {USA}
}
@inproceedings{SonicPi,
author = {Aaron, Samuel and Blackwell, Alan F.},
title = {From sonic Pi to overtone: creative musical experiences with domain-specific and functional languages},
year = {2013},
isbn = {9781450323864},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2505341.2505346},
doi = {10.1145/2505341.2505346},
abstract = {Domain Specific and Functional languages provide an excellent linguistic context for exploring new forms of music notation -- not just for formalising compositions but also for live interaction workflows. This experience report describes two novel live coding systems that employ code execution to modify live sounds and music. The first of these systems, Sonic Pi, aims at teaching core computing notions to school students using live-coded music as a means of stimulating and maintaining student engagement. We describe how an emphasis on a functional style improves the ease in which core computer science concepts can be communicated to students. Secondly we describe Overtone, a functional language and live coding environment aimed towards mprofessional electronic musicians. We describe how Overtone's abstractions and architecture strongly benefit from a functional-oriented implementation. Both Sonic Pi and Overtone are freely available open-source platforms.},
booktitle = {Proceedings of the First ACM SIGPLAN Workshop on Functional Art, Music, Modeling \& Design},
pages = {35–46},
numpages = {12},
keywords = {computational thinking, live coding, pedagogy, raspberry pi, sound synthesis},
location = {Boston, Massachusetts, USA},
series = {FARM '13}
}
@inproceedings{Elm,
author = {Czaplicki, Evan and Chong, Stephen},
title = {Asynchronous functional reactive programming for GUIs},
year = {2013},
isbn = {9781450320146},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491956.2462161},
doi = {10.1145/2491956.2462161},
abstract = {Graphical user interfaces (GUIs) mediate many of our interactions with computers. Functional Reactive Programming (FRP) is a promising approach to GUI design, providing high-level, declarative, compositional abstractions to describe user interactions and time-dependent computations. We present Elm, a practical FRP language focused on easy creation of responsive GUIs. Elm has two major features: simple declarative support for Asynchronous FRP; and purely functional graphical layout.Asynchronous FRP allows the programmer to specify when the global ordering of event processing can be violated, and thus enables efficient concurrent execution of FRP programs; long-running computation can be executed asynchronously and not adversely affect the responsiveness of the user interface.Layout in Elm is achieved using a purely functional declarative framework that makes it simple to create and combine text, images, and video into rich multimedia displays.Together, Elm's two major features simplify the complicated task of creating responsive and usable GUIs.},
booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {411–422},
numpages = {12},
keywords = {graphical user interfaces, functional reactive programming},
location = {Seattle, Washington, USA},
series = {PLDI '13}
}
@InProceedings{Racket,
  author =	{Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram and Barzilay, Eli and McCarthy, Jay and Tobin-Hochstadt, Sam},
  title =	{The Racket Manifesto},
  booktitle =	{1st Summit on Advances in Programming Languages (SNAPL 2015)},
  pages =	{113--128},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-939897-80-4},
  ISSN =	{1868-8969},
  year =	{2015},
  volume =	{32},
  editor =	{Ball, Thomas and Bodík, Rastislav and Krishnamurthi, Shriram and Lerner, Benjamin S. and Morriset, Greg},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SNAPL.2015.113},
  URN =		{urn:nbn:de:0030-drops-50211},
  doi =		{10.4230/LIPIcs.SNAPL.2015.113},
  annote =	{Keywords: design guidelines, language generation, full-spectrum language}
}
@inproceedings{Grace,
author = {Black, Andrew P. and Bruce, Kim B. and Homer, Michael and Noble, James},
title = {Grace: the absence of (inessential) difficulty},
year = {2012},
isbn = {9781450315623},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2384592.2384601},
doi = {10.1145/2384592.2384601},
abstract = {We are engaged in the design of a small, simple programming language for teaching novices object-oriented programming. This turns out to be far from a small, simple task. We focus on three of the problems that we encountered, and how we believe we have solved them. The problems are (1) gracefully combining object initialization, inheritance, and immutable objects, (2) reconciling apparently irreconcilable views on type-checking, and (3) providing a family of languages, each suitable for students at different levels of mastery, while ensuring conceptual integrity of their designs. In each case our solutions are based on existing research; our contribution is, by design, consolidation rather than innovation.},
booktitle = {Proceedings of the ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {85–98},
numpages = {14},
keywords = {grace},
location = {Tucson, Arizona, USA},
series = {Onward! 2012}
}
@online{Pyret,
  url={https://pyret.org/pyret-code/index.html},
  title={They Pyret Code; or A Rationale for the Pyret Programming Language},
  year={2016},
  author={{Pyret Crew}}
}
@article{ThingLab,
author = {Borning, Alan},
title = {The Programming Language Aspects of ThingLab, a Constraint-Oriented Simulation Laboratory},
year = {1981},
issue_date = {Oct. 1981},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {4},
issn = {0164-0925},
url = {https://doi.org/10.1145/357146.357147},
doi = {10.1145/357146.357147},
journal = {ACM Trans. Program. Lang. Syst.},
month = {10},
pages = {353–387},
numpages = {35}
}
@inproceedings{ThingLab2,
author = {Moloney, J. and Borning, Alan and Freeman-Benson, B.},
title = {Constraint technology for user-interface construction in ThingLab II},
year = {1989},
isbn = {0897913337},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/74877.74917},
doi = {10.1145/74877.74917},
abstract = {ThingLab II is an object-oriented constraint programming system designed specifically for interactive user interface construction and implemented in Smalltalk-80 For constraints to be effective in building user interfaces, they must not impede the responsiveness of the user interface either at run time or during construction. The necessary speed is attained in ThingLab II by making judicious tradeoffs between compilation and interpretation, and by using a fast, incremental algorithm for constraint satisfaction. The resulting system allows user interface components to be assembled, tested, and modified expediently while maintaining interactive responsiveness.},
booktitle = {Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications},
pages = {381–388},
numpages = {8},
location = {New Orleans, Louisiana, USA},
series = {OOPSLA '89}
}
@inproceedings{GToolkit,
author = {Chi\c{s}, Andrei and Nierstrasz, Oscar and G\^{\i}rba, Tudor},
title = {Towards moldable development tools},
year = {2015},
isbn = {9781450339070},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2846680.2846684},
doi = {10.1145/2846680.2846684},
abstract = {Developers commonly ask detailed and domain-specific questions about the software systems they are developing and maintaining. Integrated development environments (IDEs) form an essential category of tools for developing software that should support software engineering decision making. Unfortunately, rigid and generic IDEs that focus on low-level programming tasks, that promote code rather than data, and that suppress customization, offer limited support for informed decision making during software development. We propose to improve decision making within IDEs by moving from generic to context-aware IDEs through moldable tools. In this paper, we promote the idea of moldable tools, illustrate it with concrete examples, and discuss future research directions.},
booktitle = {Proceedings of the 6th Workshop on Evaluation and Usability of Programming Languages and Tools},
pages = {25–26},
numpages = {2},
keywords = {IDEs, adaptation, customization, modeling},
location = {Pittsburgh, PA, USA},
series = {PLATEAU 2015}
}
@inproceedings{Helvetia,
author = {Renggli, Lukas and G\^{\i}rba, Tudor},
title = {Why Smalltalk wins the host languages shootout},
year = {2009},
isbn = {9781605588995},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1735935.1735954},
doi = {10.1145/1735935.1735954},
abstract = {Integration of multiple languages into each other and into an existing development environment is a difficult task. As a consequence, developers often end up using only internal DSLs that strictly rely on the constraints imposed by the host language. Infrastructures do exist to mix languages, but they often do it at the price of losing the development tools of the host language. Instead of inventing a completely new infrastructure, our solution is to integrate new languages deeply into the existing host environment and reuse the infrastructure offered by it. In this paper we show why Smalltalk is the best practical choice for such a host language.},
booktitle = {Proceedings of the International Workshop on Smalltalk Technologies},
pages = {107–113},
numpages = {7},
keywords = {domain-specific languages, embedded languages, programming environments and tools},
location = {Brest, France},
series = {IWST '09}
}
@INPROCEEDINGS{TinyEds,
  author={Hempel, Brian and Chugh, Ravi},
  booktitle={2020 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)}, 
  title={Tiny Structure Editors for Low, Low Prices! (Generating GUIs from toString Functions)}, 
  year={2020},
  volume={},
  number={},
  pages={1-5},
  keywords={Visualization;Buildings;Writing;Programming},
  doi={10.1109/VL/HCC50065.2020.9127256}}
}
@inproceedings{Lively,
author = {Ingalls, Dan},
title = {The Lively Kernel: just for fun, let's take JavaScript seriously},
year = {2008},
isbn = {9781605582702},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1408681.1408690},
doi = {10.1145/1408681.1408690},
abstract = {The Sun Labs Lively Kernel is a new approach to Web programming. It provides a complete platform for Web applications, including dynamic graphics, network access, and development tools, and requires nothing more than available web browsers. We call the system "lively" for three reasons. It comes live off a web page. There is no installation. The entire system is written in JavaScript, and it becomes active as soon as the page is loaded by a browser. It can change itself and create new content. The Lively Kernel includes a basic graphics editor that allows it to alter and create new graphical content, and also a simple IDE that allows it to alter and create new applications. It comes with a basic library of graphical and computational components, and these, as well as the kernel, can be altered and extended on the fly. It can save new artifacts, even clone itself, onto new web pages. The kernel includes WebDAV support for browsing and extending remote file systems, and thus has the ability to save its objects and "worlds" (applications) as new active Web pages. The Lively Kernel uses only existing Web standards. The implementation and user language is JavaScript, known by millions and supported in every browser. The graphics APIs are built upon SVG (Scalable Vector Graphics), also available in major browsers. The network protocols used are asynchronous HTTP and WebDAV. The speaker will demonstrate the Lively Kernel and discuss various aspects of JavaScript as a programming language.},
booktitle = {Proceedings of the 2008 Symposium on Dynamic Languages},
articleno = {9},
numpages = {1},
location = {Paphos, Cyprus},
series = {DLS '08}
}
@BOOK{Pharo,
  title     = "Deep into Pharo",
  author    = "Bergel, Alexandre and Cassou, Damien and Ducasse, St{\'e}phane
               and Laval, Jannik",
  abstract  = "``Pharo is a clean, innovative, open-source, live-programming
               environment. Deep into Pharo is the second volume of a series of
               books covering Pharo. Whereas the first volume is intended for
               newcomers, this second volume covers deeper topics. You will
               learn about Pharo frameworks and libraries such as Glamour,
               PetitParser, Roassal, FileSystem, Regex, and Socket. You will
               explore the language with chapters on exceptions, blocks, small
               integers, and floats. You will discover tools such as profilers,
               Metacello and Gofer.''--Open Textbook Library.",
  publisher = "Lulu.com",
  year      =  2013,
  address   = "Morrisville, NC",
  language  = "en"
}
@inbook{Lambda,
	abstract = {Formulas in Excel have seen numerous fantastic advances in recent years including the introduction of dynamic array formulas and many brilliant new functions such as TEXTJOIN, XLOOKUP, and STOCKHISTORY. The development of LAMBDA functions in Excel was another tremendous leap in the advancement of formulas in Excel.},
	address = {Berkeley, CA},
	author = {Murray, Alan},
	booktitle = {Advanced Excel Formulas: Unleashing Brilliance with Excel Formulas},
	doi = {10.1007/978-1-4842-7125-4_15},
	isbn = {978-1-4842-7125-4},
	pages = {751--803},
	publisher = {Apress},
	title = {LET, LAMBDA, and the Helper Functions},
	url = {https://doi.org/10.1007/978-1-4842-7125-4_15},
	year = {2022},
	bdsk-url-1 = {https://doi.org/10.1007/978-1-4842-7125-4_15}
}
@article{Tombstone,
author = {John Wickerson and Paul Brunet},
year = {2012},
title = {Pearl: Diagrams for Composing Compilers},
url = {https://johnwickerson.github.io/papers/jdiagrams.pdf},
}
@article{JVM,
url = {https://docs.oracle.com/javase/specs/jvms/se21/html/index.html},
year = {2023},
title = {The Java® Virtual Machine Specification},
subtitle = {Java SE 21 Edition},
author = { Tim Lindholm and Frank Yellin and Gilad Bracha and Alex Buckley and Daniel Smith },
}
@book{TAPL,
author = {Pierce, Benjamin C.},
title = {Types and Programming Languages},
year = {2002},
isbn = {0262162091},
publisher = {The MIT Press},
edition = {1st},
abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}
@article{Lucid,
  title={Integrating Lucid’s Declarative Dataflow Paradigm into Object-Orientation},
  author={Orchard, Dominic A and Matthews, Steve},
  journal={Mathematics in Computer Science},
  volume={2},
  pages={103--122},
  year={2008},
  publisher={Springer}
}
@article{Paging,
  title={Design and Implementation of the Berkeley Virtual Memory Extensions to the UNIX Operating System},
  author={Babao\~{g}lu, \"{O}zalp and Joy, William and Porcar, Juan},
  journal={Department of Electrical Engineering and Computer Science, University of California, Berkeley},
  year={1979}
}
@inproceedings{10.1145/1028976.1029004,
author = {Bracha, Gilad and Ungar, David},
title = {Mirrors: design principles for meta-level facilities of object-oriented programming languages},
year = {2004},
isbn = {1581138318},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1028976.1029004},
doi = {10.1145/1028976.1029004},
abstract = {We identify three design principles for reflection and metaprogramming facilities in object oriented programming languages. <i>Encapsulation</i>: meta-level facilities must encapsulate their implementation. <i>Stratification</i>: meta-level facilities must be separated from base-level functionality. <i>Ontological correspondence</i>: the ontology of meta-level facilities should correspond to the ontology of the language they manipulate. Traditional/mainstream reflective architectures do not follow these precepts. In contrast, reflective APIs built around the concept of <i>mirrors</i> are characterized by adherence to these three principles. Consequently, mirror-based architectures have significant advantages with respect to distribution, deployment and general purpose metaprogramming.},
booktitle = {Proceedings of the 19th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {331–344},
numpages = {14},
keywords = {smalltalk, self, reflection, mirrors, metaprogramming, java},
location = {Vancouver, BC, Canada},
series = {OOPSLA '04}
}
@article{Mirrors,
author = {Bracha, Gilad and Ungar, David},
title = {Mirrors: design principles for meta-level facilities of object-oriented programming languages},
year = {2004},
issue_date = {October 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1035292.1029004},
doi = {10.1145/1035292.1029004},
abstract = {We identify three design principles for reflection and metaprogramming facilities in object oriented programming languages. <i>Encapsulation</i>: meta-level facilities must encapsulate their implementation. <i>Stratification</i>: meta-level facilities must be separated from base-level functionality. <i>Ontological correspondence</i>: the ontology of meta-level facilities should correspond to the ontology of the language they manipulate. Traditional/mainstream reflective architectures do not follow these precepts. In contrast, reflective APIs built around the concept of <i>mirrors</i> are characterized by adherence to these three principles. Consequently, mirror-based architectures have significant advantages with respect to distribution, deployment and general purpose metaprogramming.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {331–344},
numpages = {14},
keywords = {smalltalk, self, reflection, mirrors, metaprogramming, java}
}
@inproceedings{QuasiQuote,
author = {Mainland, Geoffrey},
title = {Why It's Nice to be Quoted: Quasiquoting for Haskell},
year = {2007},
isbn = {9781595936745},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1291201.1291211},
doi = {10.1145/1291201.1291211},
abstract = {Quasiquoting allows programmers to use domain specific syntax to construct program fragments. By providing concrete syntax for complex data types, programs become easier to read, easier to write, and easier to reason about and maintain. Haskell is an excellent host language for embedded domain specific languages, and quasiquoting ideally complements the language features that make Haskell perform so well in this area. Unfortunately, until now no Haskell compiler has provided support for quasiquoting. We present an implementation in GHC and demonstrate that by leveraging existing compiler capabilities, building a full quasiquoter requires little more work than writing a parser. Furthermore, we provide a compile-time guarantee that all quasiquoted data is type-correct.},
booktitle = {Proceedings of the ACM SIGPLAN Workshop on Haskell Workshop},
pages = {73–82},
numpages = {10},
keywords = {meta programming, quasiquoting},
location = {Freiburg, Germany},
series = {Haskell '07}
}
@inproceedings{ProjEdit,
author = {Steimann, Friedrich and Frenkel, Marcus and Voelter, Markus},
title = {Robust projectional editing},
year = {2017},
isbn = {9781450355254},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3136014.3136034},
doi = {10.1145/3136014.3136034},
abstract = {While contemporary projectional editors make sure that the edited programs conform to the programming language's metamodel, they do not enforce that they are also well-formed, that is, that they obey the well-formedness rules defined for the language. We show how, based on a constraint-based capture of well-formedness, projectional editors can be empowered to enforce well-formedness in much the same way they enforce conformance with the metamodel. The resulting robust edits may be more complex than ordinary, well-formedness breaking edits, and hence may require more user involvement; yet, maintaining well-formedness at all times ensures that necessary corrections of a program are linked to the edit that necessitated them, and that the projectional editor's services are never compromised by inconsistent programs. Robust projectional editing is not a straitjacket, however: If a programmer prefers to work without it, its constraint-based capture of well-formedness will still catch all introduced errors - unlike many other editor services, well-formedness checking and robust editing are based on the same implementation, and are hence guaranteed to behave consistently.},
booktitle = {Proceedings of the 10th ACM SIGPLAN International Conference on Software Language Engineering},
pages = {79–90},
numpages = {12},
keywords = {well-formedness, static semantics, projectional editing, editors, constraint propagation},
location = {Vancouver, BC, Canada},
series = {SLE 2017}
}
@article{SmashStack,
  title={Smashing The Stack for Fun and Profit},
  author={{Aleph One}},
  journal={Phrack magazine},
  volume={7},
  number={49},
  pages={14--16},
  year={1996}
}
@article{Babylonian,
  author       = {David Rauch and
                  Patrick Rein and
                  Stefan Ramson and
                  Jens Lincke and
                  Robert Hirschfeld},
  title        = {Babylonian-style Programming: Design and Implementation of an Integration
                  of Live Examples into General-purpose Source Code},
  journal      = {CoRR},
  volume       = {abs/1902.00549},
  year         = {2019},
  url          = {http://arxiv.org/abs/1902.00549},
  eprinttype    = {arXiv},
  eprint       = {1902.00549},
  timestamp    = {Tue, 21 May 2019 18:03:36 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1902-00549.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{Lively4,
author = {Lincke, Jens and Rein, Patrick and Ramson, Stefan and Hirschfeld, Robert and Taeumel, Marcel and Felgentreff, Tim},
title = {Designing a live development experience for web-components},
year = {2017},
isbn = {9781450355223},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3167109},
doi = {10.1145/3167109},
abstract = {Explorative and live development environments flourish when they can impose restrictions. Forcing a specific programming language or framework, the environment can better enhance the experience of editing code with immediate feedback or direct manipulation. Lively Kernel's user interface (UI) framework Morphic provides such a development experience when working with graphical objects in direct way giving immediate feedback during development. Our new development environment Lively4 achieves a similar development experience, but targeting general HTML elements. Web Components as a new Web standard provide a very powerful abstraction mechanism. Plain HTML elements provide direct building blocks for tools and applications. Unfortunately, Web Components miss proper capabilities to support run-time development. To address this issue, we use object migration to provide immediate feedback when editing UI code. The approach is evaluated by discussing known problems, resulting best practices and future work.},
booktitle = {Proceedings of the 3rd ACM SIGPLAN International Workshop on Programming Experience},
pages = {28–35},
numpages = {8},
keywords = {Web-based Programming Environment, Web Components, Live Programming, JavaScript},
location = {Vancouver, BC, Canada},
series = {PX/17.2}
}
@InProceedings{DesignScript,
author="Aish, Robert",
editor="Gengnagel, Christoph
and Kilian, Axel
and Palz, Norbert
and Scheurer, Fabian",
title="DesignScript: Origins, Explanation, Illustration",
booktitle="Computational Design Modelling",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--8",
abstract="DesignScript, as the name suggests, is positioned at the intersection of design and programming. DesignScript can be viewed as part of the continuing tradition of the development of parametric and associative modeling tools for advanced architectural design and building engineering. Much of the thought processes that contribute to the effective use of DesignScript builds on the tradition of parametric design and associative modeling that is already widely distributed amongst the creative members of the architectural and engineering communities. Many of the existing parametric and associative modelling tools also support conventional scripting via connections to existing programming languages. The originality of DesignScript is that associative and parametric modeling is integrated with conventional scripting. Indeed, the definition of the associative and parametric model is recorded directly in DesignScript. But it is not what DesignScript does which is important, more what a designer can do with DesignScript. It is this change in the way you think that makes DesignScript worth learning.",
isbn="978-3-642-23435-4"
}
@inproceedings{FourRs,
author = {Orchard, Dominic},
title = {The four Rs of programming language design},
year = {2011},
isbn = {9781450309417},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2089131.2089138},
doi = {10.1145/2089131.2089138},
booktitle = {Proceedings of the 10th SIGPLAN Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {157–162},
numpages = {6},
keywords = {the four Rs, programming language design, domain-specific languages},
location = {Portland, Oregon, USA},
series = {Onward! 2011}
}
